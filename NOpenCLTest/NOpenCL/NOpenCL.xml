<?xml version="1.0"?>
<doc>
    <assembly>
        <name>NOpenCL</name>
    </assembly>
    <members>
        <member name="T:NOpenCL.AccessQualifier">
            <summary>
            Specifies the access qualifier for a kernel argument.
            </summary>
        </member>
        <member name="F:NOpenCL.AccessQualifier.None">
            <summary>
            The access qualifier for arguments which are not an image type.
            </summary>
        </member>
        <member name="F:NOpenCL.AccessQualifier.ReadOnly">
            <summary>
            Specifies that an image argument can only be read by a kernel.
            </summary>
            <remarks>
            <para>This is the default access qualifier if one is not explicitly specified.</para>
            </remarks>
        </member>
        <member name="F:NOpenCL.AccessQualifier.WriteOnly">
            <summary>
            Specifies that an image argument can only be written by a kernel.
            </summary>
        </member>
        <member name="F:NOpenCL.AccessQualifier.ReadWrite">
            <summary>
            Specifies that an image argument can be read or written by a kernel.
            </summary>
        </member>
        <member name="T:NOpenCL.AddressingMode">
            <summary>
            Specifies the image addressing-mode i.e. how out-of-range image coordinates are handled.
            </summary>
            <remarks>
            <para>
            For 1D and 2D image arrays, the addressing mode applies only to the x and (x, y)
            coordinates. The addressing mode for the coordinate which specifies the array index
            is always <see cref="F:NOpenCL.AddressingMode.ClampToEdge"/>.
            </para>
            </remarks>
        </member>
        <member name="F:NOpenCL.AddressingMode.None">
            <summary>
            For this addressing mode the programmer guarantees that the image coordinates
            used to sample elements of the image refer to a location inside the image;
            otherwise the results are undefined.
            </summary>
        </member>
        <member name="F:NOpenCL.AddressingMode.ClampToEdge">
            <summary>
            Out-of-range image coordinates are clamped to the extent.
            </summary>
        </member>
        <member name="F:NOpenCL.AddressingMode.Clamp">
            <summary>
            Out-of-range image coordinates will return a border color. This is similar to
            the GL_ADDRESS_CLAMP_TO_BORDER addressing mode.
            </summary>
        </member>
        <member name="F:NOpenCL.AddressingMode.Repeat">
            <summary>
            Out-of-range image coordinates are wrapped to the valid range. This address mode
            can only be used with normalized coordinates. If normalized coordinates are not
            used, this addressing mode may generate image coordinates that are undefined.
            </summary>
        </member>
        <member name="F:NOpenCL.AddressingMode.MirroredRepeat">
            <summary>
            Flip the image coordinate at every integer junction. This addressing mode can
            only be used with normalized coordinates. If normalized coordinates are not
            used, this addressing mode may generate image coordinates that are undefined.
            </summary>
        </member>
        <member name="T:NOpenCL.AddressQualifier">
            <summary>
            The address space qualifier used in a variable declaration.
            </summary>
        </member>
        <member name="F:NOpenCL.AddressQualifier.Global">
            <summary>
            The <c>__global</c> or <c>global</c> address space name is used to refer to
            memory objects (buffer or image objects) allocated from the global memory pool.
            </summary>
        </member>
        <member name="F:NOpenCL.AddressQualifier.Local">
            <summary>
            The <c>__local</c> or <c>local</c> address space name is used to describe
            variables that need to be allocated in local memory and are shared by all
            work-items of a work-group.
            </summary>
        </member>
        <member name="F:NOpenCL.AddressQualifier.Constant">
            <summary>
            The <c>__constant</c> or <c>constant</c> address space name is used to describe
            variables allocated in global memory and which are accessed inside a kernel(s)
            as read-only variables.
            </summary>
        </member>
        <member name="F:NOpenCL.AddressQualifier.Private">
            <summary>
            Variables inside a kernel function not declared with an address space qualifier,
            all variables inside non-kernel functions, and all function arguments are in the
            <c>__private</c> or <c>private</c> address space. Variables declared as pointers
            are considered to point to the <c>__private</c> address space if an address
            space qualifier is not specified.
            </summary>
        </member>
        <member name="T:NOpenCL.AffinityDomain">
            <summary>
            Defines the cache parts of the cache hierarchy which are used for splitting a device into smaller
            aggregate devices containing one or more compute units that all share part of a cache hierarchy.
            </summary>
            <seealso cref="M:NOpenCL.Device.PartitionByAffinityDomain(NOpenCL.AffinityDomain)"/>
        </member>
        <member name="F:NOpenCL.AffinityDomain.Numa">
            <summary>
            Split the device into sub-devices comprised of compute units that share a NUMA node.
            </summary>
        </member>
        <member name="F:NOpenCL.AffinityDomain.L4Cache">
            <summary>
            Split the device into sub-devices comprised of compute units that share a level 4 data cache.
            </summary>
        </member>
        <member name="F:NOpenCL.AffinityDomain.L3Cache">
            <summary>
            Split the device into sub-devices comprised of compute units that share a level 3 data cache.
            </summary>
        </member>
        <member name="F:NOpenCL.AffinityDomain.L2Cache">
            <summary>
            Split the device into sub-devices comprised of compute units that share a level 2 data cache.
            </summary>
        </member>
        <member name="F:NOpenCL.AffinityDomain.L1Cache">
            <summary>
            Split the device into sub-devices comprised of compute units that share a level 1 data cache.
            </summary>
        </member>
        <member name="F:NOpenCL.AffinityDomain.NextPartitionable">
            <summary>
            Split the device along the next partitionable affinity domain. The implementation shall find
            the first level along which the device or sub-device may be further subdivided in the order
            NUMA, L4, L3, L2, L1, and partition the device into sub-devices comprised of compute units
            that share memory subsystems at this level.
            </summary>
        </member>
        <member name="T:NOpenCL.BinaryType">
            <summary>
            The program binary type for a device.
            </summary>
        </member>
        <member name="F:NOpenCL.BinaryType.None">
            <summary>
            There is no binary associated with the device.
            </summary>
        </member>
        <member name="F:NOpenCL.BinaryType.CompiledObject">
            <summary>
            A compiled binary is associated with the device. This is the case if a program
            was created using <see cref="M:NOpenCL.Context.CreateProgramWithSource(System.String[])"/> and compiled
            using <see cref="!:Program.Compile"/> or a compiled binary is loaded using
            <see cref="!:Context.CreateProgramWithBinary"/>.
            </summary>
        </member>
        <member name="F:NOpenCL.BinaryType.Library">
            <summary>
            A library binary is associated with the device. This is the case if a program
            was created by <see cref="!:Program.Link"/> which is called with the
            <c>–createlibrary</c> link option or if a library binary is loaded using
            <see cref="!:Context.CreateProgramWithBinary"/>.
            </summary>
        </member>
        <member name="F:NOpenCL.BinaryType.Executable">
            <summary>
            An executable binary is associated with the device. This is the case if a
            program was created by <see cref="!:Program.Link"/> without the <c>–createlibrary</c>
            link option or the program was created by <see cref="O:NOpenCL.Program.Build"/>
            or an executable binary is loaded using <see cref="!:Context.CreateProgramWithBinary"/>.
            </summary>
        </member>
        <member name="T:NOpenCL.BufferCreateType">
            <summary>
            Describes the type of buffer object to be created by <see cref="M:NOpenCL.Buffer.CreateSubBuffer(NOpenCL.MemoryFlags,NOpenCL.BufferRegion)"/>.
            </summary>
        </member>
        <member name="F:NOpenCL.BufferCreateType.Region">
            <summary>
            A sub-buffer that represents a specific region in the parent buffer.
            </summary>
        </member>
        <member name="T:NOpenCL.UnsafeNativeMethods">
            <content>
            Flush and finish.
            </content>
            <content>
            Executing kernels.
            </content>
            <content>
            Profiling operations on memory objects and kernels.
            </content>
            <content>
            Markers, barriers, and waiting.
            </content>
            <content>
            Event objects.
            </content>
            <content>
            Kernel objects.
            </content>
            <content>
            Program objects.
            </content>
            <content>
            Sampler objects.
            </content>
            <content>
            Buffer objects.
            </content>
            <content>
            Command queues.
            </content>
            <summary>
            Contexts.
            </summary>
            <content>
            Partitioning a device.
            </content>
            <content>
            Devices.
            </content>
            <content>
            Platforms.
            </content>
        </member>
        <member name="M:NOpenCL.UnsafeNativeMethods.clFlush(NOpenCL.SafeHandles.CommandQueueSafeHandle)">
             <summary>
             Issues all previously queued OpenCL commands in a command-queue to the device associated with the command-queue.
             http://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/clFlush.html
             http://www.khronos.org/registry/cl/specs/opencl-1.2.pdf#page=193
             </summary>
             <remarks>
             Issues all previously queued OpenCL commands in <paramref name="commandQueue"/>
             to the device associated with <paramref name="commandQueue"/>.
            
             <para>
             <see cref="M:NOpenCL.UnsafeNativeMethods.clFlush(NOpenCL.SafeHandles.CommandQueueSafeHandle)"/> only guarantees that all queued commands to
             <paramref name="commandQueue"/> will eventually be submitted to the appropriate
             device. There is no guarantee that they will be complete after <see cref="M:NOpenCL.UnsafeNativeMethods.clFlush(NOpenCL.SafeHandles.CommandQueueSafeHandle)"/>
             returns.
             </para>
            
             <para>
             Any blocking commands queued in a command-queue and <see cref="M:NOpenCL.UnsafeNativeMethods.clReleaseCommandQueue(System.IntPtr)"/>
             perform an implicit flush of the command-queue. These blocking commands are
             <see cref="M:NOpenCL.UnsafeNativeMethods.clEnqueueReadBuffer(NOpenCL.SafeHandles.CommandQueueSafeHandle,NOpenCL.SafeHandles.BufferSafeHandle,System.Boolean,System.IntPtr,System.IntPtr,System.IntPtr,System.UInt32,NOpenCL.SafeHandles.EventSafeHandle[],NOpenCL.SafeHandles.EventSafeHandle@)"/>, <see cref="M:NOpenCL.UnsafeNativeMethods.clEnqueueReadBufferRect(NOpenCL.SafeHandles.CommandQueueSafeHandle,NOpenCL.SafeHandles.BufferSafeHandle,System.Boolean,NOpenCL.BufferCoordinates@,NOpenCL.BufferCoordinates@,NOpenCL.BufferSize@,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.UInt32,NOpenCL.SafeHandles.EventSafeHandle[],NOpenCL.SafeHandles.EventSafeHandle@)"/>, or
             <see cref="M:NOpenCL.UnsafeNativeMethods.clEnqueueReadImage(NOpenCL.SafeHandles.CommandQueueSafeHandle,NOpenCL.SafeHandles.ImageSafeHandle,System.Boolean,NOpenCL.BufferCoordinates@,NOpenCL.BufferSize@,System.IntPtr,System.IntPtr,System.IntPtr,System.UInt32,NOpenCL.SafeHandles.EventSafeHandle[],NOpenCL.SafeHandles.EventSafeHandle@)"/> with <em>blockingRead</em> set to <c>true</c>;
             <see cref="M:NOpenCL.UnsafeNativeMethods.clEnqueueWriteBuffer(NOpenCL.SafeHandles.CommandQueueSafeHandle,NOpenCL.SafeHandles.BufferSafeHandle,System.Boolean,System.IntPtr,System.IntPtr,System.IntPtr,System.UInt32,NOpenCL.SafeHandles.EventSafeHandle[],NOpenCL.SafeHandles.EventSafeHandle@)"/>, <see cref="M:NOpenCL.UnsafeNativeMethods.clEnqueueWriteBufferRect(NOpenCL.SafeHandles.CommandQueueSafeHandle,NOpenCL.SafeHandles.BufferSafeHandle,System.Boolean,NOpenCL.BufferCoordinates@,NOpenCL.BufferCoordinates@,NOpenCL.BufferSize@,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.UInt32,NOpenCL.SafeHandles.EventSafeHandle[],NOpenCL.SafeHandles.EventSafeHandle@)"/>, or
             <see cref="M:NOpenCL.UnsafeNativeMethods.clEnqueueWriteImage(NOpenCL.SafeHandles.CommandQueueSafeHandle,NOpenCL.SafeHandles.ImageSafeHandle,System.Boolean,NOpenCL.BufferCoordinates@,NOpenCL.BufferSize@,System.IntPtr,System.IntPtr,System.IntPtr,System.UInt32,NOpenCL.SafeHandles.EventSafeHandle[],NOpenCL.SafeHandles.EventSafeHandle@)"/> with <em>blockingWrite</em> set to <c>true</c>;
             <see cref="M:NOpenCL.UnsafeNativeMethods.clEnqueueMapBuffer(NOpenCL.SafeHandles.CommandQueueSafeHandle,NOpenCL.SafeHandles.BufferSafeHandle,System.Boolean,NOpenCL.MapFlags,System.IntPtr,System.IntPtr,System.UInt32,NOpenCL.SafeHandles.EventSafeHandle[],NOpenCL.SafeHandles.EventSafeHandle@,NOpenCL.UnsafeNativeMethods.ErrorCode@)"/> or <see cref="M:NOpenCL.UnsafeNativeMethods.clEnqueueMapImage(NOpenCL.SafeHandles.CommandQueueSafeHandle,NOpenCL.SafeHandles.ImageSafeHandle,System.Boolean,NOpenCL.MapFlags,NOpenCL.BufferCoordinates@,NOpenCL.BufferSize@,System.IntPtr@,System.IntPtr@,System.UInt32,NOpenCL.SafeHandles.EventSafeHandle[],NOpenCL.SafeHandles.EventSafeHandle@,NOpenCL.UnsafeNativeMethods.ErrorCode@)"/> with
             <em>blockingMap</em> set to <c>true</c>; or <see cref="M:NOpenCL.UnsafeNativeMethods.clWaitForEvents(System.UInt32,NOpenCL.SafeHandles.EventSafeHandle[])"/>.
             </para>
            
             <para>
             To use event objects that refer to commands enqueued in a command-queue as event
             objects to wait on by commands enqueued in a different command-queue, the
             application must call a <see cref="M:NOpenCL.UnsafeNativeMethods.clFlush(NOpenCL.SafeHandles.CommandQueueSafeHandle)"/> or any blocking commands that
             perform an implicit flush of the command-queue where the commands that refer
             to these event objects are enqueued.
             </para>
             </remarks>
             <param name="commandQueue">A valid command-queue.</param>
             <returns>
             Returns <see cref="F:NOpenCL.UnsafeNativeMethods.ErrorCode.Success"/> if the function call was executed
             successfully. Otherwise, it returns one of the following:
            
             <list type="bullet">
             <item><see cref="F:NOpenCL.UnsafeNativeMethods.ErrorCode.InvalidCommandQueue"/> if <paramref name="commandQueue"/> is not a valid command-queue.</item>
             <item><see cref="F:NOpenCL.UnsafeNativeMethods.ErrorCode.OutOfHostMemory"/> if there is a failure to allocate resources required by the OpenCL implementation on the host.</item>
             <item><see cref="F:NOpenCL.UnsafeNativeMethods.ErrorCode.OutOfResources"/> if there is a failure to allocate resources required by the OpenCL implementation on the device.</item>
             </list>
             </returns>
             <seealso cref="M:NOpenCL.UnsafeNativeMethods.clFinish(NOpenCL.SafeHandles.CommandQueueSafeHandle)"/>
        </member>
        <member name="M:NOpenCL.UnsafeNativeMethods.clFinish(NOpenCL.SafeHandles.CommandQueueSafeHandle)">
             <summary>
             Blocks until all previously queued OpenCL commands in a command-queue are issued to the associated device and have completed.
             http://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/clFinish.html
             </summary>
             <remarks>
             Blocks until all previously queued OpenCL commands in
             <paramref name="commandQueue"/> are issued to the associated device and
             have completed.
            
             <para>
             <see cref="M:NOpenCL.UnsafeNativeMethods.clFinish(NOpenCL.SafeHandles.CommandQueueSafeHandle)"/> does not return until all previously queued commands
             in <paramref name="commandQueue"/> have been processed and completed.
             <see cref="M:NOpenCL.UnsafeNativeMethods.clFinish(NOpenCL.SafeHandles.CommandQueueSafeHandle)"/> is also a synchronization point.
             </para>
             </remarks>
             <param name="commandQueue">A valid command-queue.</param>
             <returns>
             Returns <see cref="F:NOpenCL.UnsafeNativeMethods.ErrorCode.Success"/> if the function call was executed
             successfully. Otherwise, it returns one of the following:
            
             <list type="bullet">
             <item><see cref="F:NOpenCL.UnsafeNativeMethods.ErrorCode.InvalidCommandQueue"/> if <paramref name="commandQueue"/> is not a valid command-queue.</item>
             <item><see cref="F:NOpenCL.UnsafeNativeMethods.ErrorCode.OutOfHostMemory"/> if there is a failure to allocate resources required by the OpenCL implementation on the host.</item>
             <item><see cref="F:NOpenCL.UnsafeNativeMethods.ErrorCode.OutOfResources"/> if there is a failure to allocate resources required by the OpenCL implementation on the device.</item>
             </list>
             </returns>
             <seealso cref="M:NOpenCL.UnsafeNativeMethods.clFlush(NOpenCL.SafeHandles.CommandQueueSafeHandle)"/>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.EventProfilingInfo.CommandQueued">
            <summary>
            A 64-bit value that describes the current device time counter in nanoseconds when
            the command identified by <em>event</em> is enqueued in a command-queue by the host.
            </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.EventProfilingInfo.CommandSubmit">
            <summary>
            A 64-bit value that describes the current device time counter in nanoseconds when
            the command identified by <em>event</em> that has been enqueued is submitted by the
            host to the device associated with the command-queue.
            </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.EventProfilingInfo.CommandStart">
            <summary>
            A 64-bit value that describes the current device time counter in nanoseconds when
            the command identified by <em>event</em> starts execution on the device.
            </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.EventProfilingInfo.CommandEnd">
            <summary>
            A 64-bit value that describes the current device time counter in nanoseconds when
            the command identified by <em>event</em> has finished execution on the device.
            </summary>
        </member>
        <member name="M:NOpenCL.UnsafeNativeMethods.clEnqueueMarkerWithWaitList(NOpenCL.SafeHandles.CommandQueueSafeHandle,System.UInt32,NOpenCL.SafeHandles.EventSafeHandle[],NOpenCL.SafeHandles.EventSafeHandle@)">
             <summary>
             Enqueues a marker command which waits for either a list of events to complete, or all previously enqueued commands to complete.
             http://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/clEnqueueMarkerWithWaitList.html
             http://www.khronos.org/registry/cl/specs/opencl-1.2.pdf#page=186
             </summary>
             <remarks>
             Enqueues a marker command which waits for either a list of events to complete,
             or if the list is empty it waits for all commands previously enqueued in
             <paramref name="commandQueue"/> to complete before it completes. This command
             returns an event which can be waited on, i.e. this event can be waited on to
             ensure that all events either in the <paramref name="eventWaitList"/> or all
             previously enqueued commands, queued before this command to
             <paramref name="commandQueue"/>, have completed.
             </remarks>
             <param name="commandQueue">A valid command-queue.</param>
             <param name="numEventsInWaitList">The number of events in <paramref name="eventWaitList"/>.</param>
             <param name="eventWaitList">The events that need to complete before this particular command can be executed.
             If <paramref name="eventWaitList"/> is <see langword="null"/>, then this particular command does not wait on
             any event to complete. If <paramref name="eventWaitList"/> is <see langword="null"/>,
             <paramref name="numEventsInWaitList"/> must be 0. If <paramref name="eventWaitList"/> is not
             <see langword="null"/>, the list of events pointed to by <paramref name="eventWaitList"/> must be valid and
             <paramref name="numEventsInWaitList"/> must be greater than 0.</param>
             <param name="event">Returns an event object that identifies this particular command.</param>
             <returns>
             Returns <see cref="F:NOpenCL.UnsafeNativeMethods.ErrorCode.Success"/> if the function executed successfully,
             or one of the errors below:
            
             <list type="bullet">
             <item><see cref="F:NOpenCL.UnsafeNativeMethods.ErrorCode.InvalidCommandQueue"/> if <paramref name="commandQueue"/> is not a valid command-queue.</item>
             <item><see cref="F:NOpenCL.UnsafeNativeMethods.ErrorCode.InvalidEventWaitList"/> if <paramref name="eventWaitList"/> is <c>null</c> and <paramref name="numEventsInWaitList"/> &gt; 0, or <paramref name="eventWaitList"/> is not <c>null</c> and <paramref name="numEventsInWaitList"/> is 0, or if event objects in <paramref name="eventWaitList"/> are not valid events.</item>
             <item><see cref="F:NOpenCL.UnsafeNativeMethods.ErrorCode.OutOfResources"/> if there is a failure to allocate resources required by the OpenCL implementation on the device.</item>
             <item><see cref="F:NOpenCL.UnsafeNativeMethods.ErrorCode.OutOfHostMemory"/> if there is a failure to allocate resources required by the OpenCL implementation on the host.</item>
             </list>
             </returns>
        </member>
        <member name="M:NOpenCL.UnsafeNativeMethods.clEnqueueBarrierWithWaitList(NOpenCL.SafeHandles.CommandQueueSafeHandle,System.UInt32,NOpenCL.SafeHandles.EventSafeHandle[],NOpenCL.SafeHandles.EventSafeHandle@)">
             <summary>
             A synchronization point that enqueues a barrier operation.
             http://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/clEnqueueBarrierWithWaitList.html
             http://www.khronos.org/registry/cl/specs/opencl-1.2.pdf#page=187
             </summary>
             <remarks>
             Enqueues a barrier command which waits for either a list of events to complete,
             or if the list is empty it waits for all commands previously enqueued in
             <paramref name="commandQueue"/> to complete before it completes. This command
             blocks command execution, that is, any following commands enqueued after it do
             not execute until it completes. This command returns an event which can be
             waited on, i.e. this event can be waited on to ensure that all events either
             in the <paramref name="eventWaitList"/> or all previously enqueued commands,
             queued before this command to <paramref name="commandQueue"/>, have completed.
             </remarks>
             <param name="commandQueue">A valid command-queue.</param>
             <param name="numEventsInWaitList">The number of events in <paramref name="eventWaitList"/>.</param>
             <param name="eventWaitList">The events that need to complete before this particular command can be executed.
             If <paramref name="eventWaitList"/> is <see langword="null"/>, then this particular command does not wait on
             any event to complete. If <paramref name="eventWaitList"/> is <see langword="null"/>,
             <paramref name="numEventsInWaitList"/> must be 0. If <paramref name="eventWaitList"/> is not
             <see langword="null"/>, the list of events pointed to by <paramref name="eventWaitList"/> must be valid and
             <paramref name="numEventsInWaitList"/> must be greater than 0.</param>
             <param name="event">Returns an event object that identifies this particular command.</param>
             <returns>
             Returns <see cref="F:NOpenCL.UnsafeNativeMethods.ErrorCode.Success"/> if the function executed successfully,
             or one of the errors below:
            
             <list type="bullet">
             <item><see cref="F:NOpenCL.UnsafeNativeMethods.ErrorCode.InvalidCommandQueue"/> if <paramref name="commandQueue"/> is not a valid command-queue.</item>
             <item><see cref="F:NOpenCL.UnsafeNativeMethods.ErrorCode.InvalidEventWaitList"/> if <paramref name="eventWaitList"/> is <c>null</c> and <paramref name="numEventsInWaitList"/> &gt; 0, or <paramref name="eventWaitList"/> is not <c>null</c> and <paramref name="numEventsInWaitList"/> is 0, or if event objects in <paramref name="eventWaitList"/> are not valid events.</item>
             <item><see cref="F:NOpenCL.UnsafeNativeMethods.ErrorCode.OutOfResources"/> if there is a failure to allocate resources required by the OpenCL implementation on the device.</item>
             <item><see cref="F:NOpenCL.UnsafeNativeMethods.ErrorCode.OutOfHostMemory"/> if there is a failure to allocate resources required by the OpenCL implementation on the host.</item>
             </list>
             </returns>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.EventInfo.CommandQueue">
            <summary>
            Return the command-queue associated with event. For user event objects, <see cref="F:System.IntPtr.Zero"/> is returned.
            </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.EventInfo.Context">
            <summary>
            Return the context associated with event.
            </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.EventInfo.CommandType">
             <summary>
             Return the command associated with event. Can be one of the following values:
            
             <list type="bullet">
             <item><see cref="F:NOpenCL.CommandType.NdrangeKernel"/></item>
             <item><see cref="F:NOpenCL.CommandType.Task"/></item>
             <item><see cref="F:NOpenCL.CommandType.NativeKernel"/></item>
             <item><see cref="F:NOpenCL.CommandType.ReadBuffer"/></item>
             <item><see cref="F:NOpenCL.CommandType.WriteBuffer"/></item>
             <item><see cref="F:NOpenCL.CommandType.CopyBuffer"/></item>
             <item><see cref="F:NOpenCL.CommandType.ReadImage"/></item>
             <item><see cref="F:NOpenCL.CommandType.WriteImage"/></item>
             <item><see cref="F:NOpenCL.CommandType.CopyImage"/></item>
             <item><see cref="F:NOpenCL.CommandType.CopyBufferToImage"/></item>
             <item><see cref="F:NOpenCL.CommandType.CopyImageToBuffer"/></item>
             <item><see cref="F:NOpenCL.CommandType.MapBuffer"/></item>
             <item><see cref="F:NOpenCL.CommandType.MapImage"/></item>
             <item><see cref="F:NOpenCL.CommandType.UnmapMemObject"/></item>
             <item><see cref="F:NOpenCL.CommandType.Marker"/></item>
             <item><see cref="F:NOpenCL.CommandType.AcquireGlObjects"/></item>
             <item><see cref="F:NOpenCL.CommandType.ReleaseGlObjects"/></item>
             <item><see cref="F:NOpenCL.CommandType.ReadBufferRect"/></item>
             <item><see cref="F:NOpenCL.CommandType.WriteBufferRect"/></item>
             <item><see cref="F:NOpenCL.CommandType.CopyBufferRect"/></item>
             <item><see cref="F:NOpenCL.CommandType.User"/></item>
             <item><see cref="F:NOpenCL.CommandType.Barrier"/></item>
             <item><see cref="F:NOpenCL.CommandType.MigrateMemObjects"/></item>
             <item><see cref="F:NOpenCL.CommandType.FillBuffer"/></item>
             <item><see cref="F:NOpenCL.CommandType.FillImage"/></item>
             <item><see cref="!:NOpenCL.CommandType.GlFenceSyncObjectKhr"/> (if cl_khr_gl_event is enabled)</item>
             <item><see cref="!:NOpenCL.CommandType.AcquireD3d10ObjectsKhr"/> (if cl_khr_d3d10_sharing is enabled)</item>
             <item><see cref="!:NOpenCL.CommandType.ReleaseD3d10ObjectsKhr"/> (if cl_khr_d3d10_sharing is enabled)</item>
             <item><see cref="!:NOpenCL.CommandType.AcquireDx9MediaSurfacesKhr"/> (if cl_khr_dx9_media_sharing is enabled)</item>
             <item><see cref="!:NOpenCL.CommandType.ReleaseDx9MediaSurfacesKhr"/> (if cl_khr_dx9_media_sharing is enabled)</item>
             <item><see cref="!:NOpenCL.CommandType.AcquireD3d11ObjectsKhr"/> (if cl_khr_d3d11_sharing is enabled)</item>
             <item><see cref="!:NOpenCL.CommandType.ReleaseD3d11ObjectsKhr"/> (if cl_khr_d3d11_sharing is enabled)</item>
             </list>
             </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.EventInfo.CommandExecutionStatus">
             <summary>
             Return the execution status of the command identified by event. The valid values are:
            
             <list type="bullet">
             <item><see cref="F:NOpenCL.ExecutionStatus.Queued"/> (command has been enqueued in the command-queue),</item>
             <item><see cref="F:NOpenCL.ExecutionStatus.Submitted"/> (enqueued command has been submitted by the host to the device associated with the command-queue),</item>
             <item><see cref="F:NOpenCL.ExecutionStatus.Running"/> (device is currently executing this command),</item>
             <item><see cref="F:NOpenCL.ExecutionStatus.Complete"/> (the command has completed), or</item>
             <item>Error code given by a negative integer value. (command was abnormally terminated – this may be caused by a bad memory access etc.) These error codes come from the same set of error codes that are returned from the platform or runtime API calls as return values or errcode_ret values.</item>
             </list>
            
             The error code values are negative, and event state values are positive. The
             event state values are ordered from the largest value (<see cref="F:NOpenCL.ExecutionStatus.Queued"/>) for the first
             or initial state to the smallest value (<see cref="F:NOpenCL.ExecutionStatus.Complete"/> or negative integer value)
             for the last or complete state. The value of <see cref="F:NOpenCL.ExecutionStatus.Complete"/> and <see cref="F:NOpenCL.UnsafeNativeMethods.ErrorCode.Success"/> are the same.
             </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.EventInfo.ReferenceCount">
            <summary>
            Return the event reference count. The reference count returned should be
            considered immediately stale. It is unsuitable for general use in applications.
            This feature is provided for identifying memory leaks.
            </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.KernelInfo.FunctionName">
            <summary>
            Return the kernel function name.
            </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.KernelInfo.NumArgs">
            <summary>
            Return the number of arguments to kernel.
            </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.KernelInfo.ReferenceCount">
            <summary>
            Return the kernel reference count.
            <para/>
            The reference count returned should be considered immediately stale. It
            is unsuitable for general use in applications. This feature is provided
            for identifying memory leaks.
            </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.KernelInfo.Context">
            <summary>
            Return the context associated with kernel.
            </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.KernelInfo.Program">
            <summary>
            Return the program object associated with kernel.
            </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.KernelInfo.Attributes">
            <summary>
            Returns any attributes specified using the <c>__attribute__</c> qualifier
            with the kernel function declaration in the program source. These attributes
            include those on the <c>__attribute__</c> page and other attributes supported
            by an implementation.
            <para/>
            Attributes are returned as they were declared inside <c>__attribute__((...))</c>,
            with any surrounding whitespace and embedded newlines removed. When multiple
            attributes are present, they are returned as a single, space delimited string.
            </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.KernelWorkGroupInfo.GlobalWorkSize">
            <summary>
            This provides a mechanism for the application to query the maximum global size
            that can be used to execute a kernel (i.e. <em>globalWorkSize</em> argument to
            <see cref="M:NOpenCL.UnsafeNativeMethods.clEnqueueNDRangeKernel(NOpenCL.SafeHandles.CommandQueueSafeHandle,NOpenCL.SafeHandles.KernelSafeHandle,System.UInt32,System.IntPtr[],System.IntPtr[],System.IntPtr[],System.UInt32,NOpenCL.SafeHandles.EventSafeHandle[],NOpenCL.SafeHandles.EventSafeHandle@)"/>) on a custom device given by device or a
            built-in kernel on an OpenCL device given by device.
            <para/>
            If device is not a custom device or kernel is not a built-in kernel,
            <see cref="M:NOpenCL.UnsafeNativeMethods.clGetKernelArgInfo(NOpenCL.SafeHandles.KernelSafeHandle,System.Int32,System.Int32,System.UIntPtr,System.IntPtr,System.UIntPtr@)"/> returns the error <see cref="F:NOpenCL.UnsafeNativeMethods.ErrorCode.InvalidValue"/>.
            </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.KernelWorkGroupInfo.WorkGroupSize">
            <summary>
            This provides a mechanism for the application to query the maximum work-group
            size that can be used to execute a kernel on a specific device given by device.
            The OpenCL implementation uses the resource requirements of the kernel (register
            usage etc.) to determine what this work-group size should be.
            </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.KernelWorkGroupInfo.CompileWorkGroupSize">
            <summary>
            Returns the work-group size specified by the <c>__attribute__((reqd_work_group_size(X, Y, Z)))</c>
            qualifier. See Function Qualifiers. If the work-group size is not specified
            using the above attribute qualifier (0, 0, 0) is returned.
            </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.KernelWorkGroupInfo.LocalMemorySize">
            <summary>
            Returns the amount of local memory in bytes being used by a kernel. This includes
            local memory that may be needed by an implementation to execute the kernel,
            variables declared inside the kernel with the <c>__local</c> address qualifier and
            local memory to be allocated for arguments to the kernel declared as pointers
            with the <c>__local</c> address qualifier and whose size is specified with
            <see cref="M:NOpenCL.UnsafeNativeMethods.clSetKernelArg(NOpenCL.SafeHandles.KernelSafeHandle,System.Int32,System.UIntPtr,System.IntPtr)"/>.
            <para/>
            If the local memory size, for any pointer argument to the kernel declared with the
            <c>__local</c> address qualifier, is not specified, its size is assumed to be 0.
            </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.KernelWorkGroupInfo.PreferredWorkGroupSizeMultiple">
            <summary>
            Returns the preferred multiple of workgroup size for launch. This is a performance
            hint. Specifying a workgroup size that is not a multiple of the value returned by
            this query as the value of the local work size argument to <see cref="M:NOpenCL.UnsafeNativeMethods.clEnqueueNDRangeKernel(NOpenCL.SafeHandles.CommandQueueSafeHandle,NOpenCL.SafeHandles.KernelSafeHandle,System.UInt32,System.IntPtr[],System.IntPtr[],System.IntPtr[],System.UInt32,NOpenCL.SafeHandles.EventSafeHandle[],NOpenCL.SafeHandles.EventSafeHandle@)"/> will
            not fail to enqueue the kernel for execution unless the work-group size specified
            is larger than the device maximum.
            </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.KernelWorkGroupInfo.PrivateMemorySize">
            <summary>
            Returns the minimum amount of private memory, in bytes, used by each workitem in
            the kernel. This value may include any private memory needed by an implementation
            to execute the kernel, including that used by the language built-ins and variable
            declared inside the kernel with the <c>__private</c> qualifier.
            </summary>
        </member>
        <member name="M:NOpenCL.UnsafeNativeMethods.clUnloadPlatformCompiler(NOpenCL.UnsafeNativeMethods.ClPlatformID)">
             <summary>
             Allows the implementation to release the resources allocated by the OpenCL compiler
             for <paramref name="platform"/>.
             http://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/clUnloadPlatformCompiler.html
             http://www.khronos.org/registry/cl/specs/opencl-1.2.pdf#page=149
             </summary>
             <remarks>
             This is a hint from the application and does not guarantee that the compiler will
             not be used in the future or that the compiler will actually be unloaded by the
             implementation. Calls to <see cref="M:NOpenCL.UnsafeNativeMethods.clBuildProgram(NOpenCL.SafeHandles.ProgramSafeHandle,System.UInt32,NOpenCL.UnsafeNativeMethods.ClDeviceID[],System.String,NOpenCL.UnsafeNativeMethods.BuildProgramCallback,System.IntPtr)"/>, <see cref="M:NOpenCL.UnsafeNativeMethods.clCompileProgram(NOpenCL.SafeHandles.ProgramSafeHandle,System.UInt32,NOpenCL.UnsafeNativeMethods.ClDeviceID[],System.String,System.UInt32,NOpenCL.SafeHandles.ProgramSafeHandle[],System.String[],NOpenCL.UnsafeNativeMethods.BuildProgramCallback,System.IntPtr)"/>,
             or <see cref="M:NOpenCL.UnsafeNativeMethods.clLinkProgram(NOpenCL.SafeHandles.ContextSafeHandle,System.UInt32,NOpenCL.UnsafeNativeMethods.ClDeviceID[],System.String,System.UInt32,NOpenCL.SafeHandles.ProgramSafeHandle[],NOpenCL.UnsafeNativeMethods.BuildProgramCallback,System.IntPtr,NOpenCL.UnsafeNativeMethods.ErrorCode@)"/> after <see cref="M:NOpenCL.UnsafeNativeMethods.clUnloadPlatformCompiler(NOpenCL.UnsafeNativeMethods.ClPlatformID)"/> will
             reload the compiler, if necessary, to build the appropriate program executable.
             </remarks>
             <param name="platform">A valid platform.</param>
             <returns>
             <see cref="M:NOpenCL.UnsafeNativeMethods.clUnloadPlatformCompiler(NOpenCL.UnsafeNativeMethods.ClPlatformID)"/> returns <see cref="F:NOpenCL.UnsafeNativeMethods.ErrorCode.Success"/>
             if the function is executed successfully. Otherwise, it returns one of the following
             errors:
            
             <list type="bullet">
             <item><see cref="F:NOpenCL.UnsafeNativeMethods.ErrorCode.InvalidPlatform"/> if <paramref name="platform"/> is not a valid platform.</item>
             </list>
             </returns>
        </member>
        <member name="M:NOpenCL.UnsafeNativeMethods.UnloadPlatformCompiler(NOpenCL.UnsafeNativeMethods.ClPlatformID)">
            <summary>
            Invokes <see cref="M:NOpenCL.UnsafeNativeMethods.clUnloadPlatformCompiler(NOpenCL.UnsafeNativeMethods.ClPlatformID)"/>, and throws an exception if
            the call does not succeed.
            </summary>
            <param name="platform">A valid platform.</param>
            <seealso cref="M:NOpenCL.Platform.UnloadCompiler"/>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.ProgramBuildInfo.BuildStatus">
             <summary>
             Returns the build, compile or link status, whichever was performed last on program for device.
             This can be one of the following:
            
             <list type="bullet">
             <item><see cref="F:NOpenCL.BuildStatus.None"/>. The build status returned if no <see cref="M:NOpenCL.UnsafeNativeMethods.clBuildProgram(NOpenCL.SafeHandles.ProgramSafeHandle,System.UInt32,NOpenCL.UnsafeNativeMethods.ClDeviceID[],System.String,NOpenCL.UnsafeNativeMethods.BuildProgramCallback,System.IntPtr)"/>, <see cref="M:NOpenCL.UnsafeNativeMethods.clCompileProgram(NOpenCL.SafeHandles.ProgramSafeHandle,System.UInt32,NOpenCL.UnsafeNativeMethods.ClDeviceID[],System.String,System.UInt32,NOpenCL.SafeHandles.ProgramSafeHandle[],System.String[],NOpenCL.UnsafeNativeMethods.BuildProgramCallback,System.IntPtr)"/> or <see cref="M:NOpenCL.UnsafeNativeMethods.clLinkProgram(NOpenCL.SafeHandles.ContextSafeHandle,System.UInt32,NOpenCL.UnsafeNativeMethods.ClDeviceID[],System.String,System.UInt32,NOpenCL.SafeHandles.ProgramSafeHandle[],NOpenCL.UnsafeNativeMethods.BuildProgramCallback,System.IntPtr,NOpenCL.UnsafeNativeMethods.ErrorCode@)"/> has been performed on the specified program object for device.</item>
             <item><see cref="F:NOpenCL.BuildStatus.Error"/>. The build status returned if <see cref="M:NOpenCL.UnsafeNativeMethods.clBuildProgram(NOpenCL.SafeHandles.ProgramSafeHandle,System.UInt32,NOpenCL.UnsafeNativeMethods.ClDeviceID[],System.String,NOpenCL.UnsafeNativeMethods.BuildProgramCallback,System.IntPtr)"/>, <see cref="M:NOpenCL.UnsafeNativeMethods.clCompileProgram(NOpenCL.SafeHandles.ProgramSafeHandle,System.UInt32,NOpenCL.UnsafeNativeMethods.ClDeviceID[],System.String,System.UInt32,NOpenCL.SafeHandles.ProgramSafeHandle[],System.String[],NOpenCL.UnsafeNativeMethods.BuildProgramCallback,System.IntPtr)"/> or <see cref="M:NOpenCL.UnsafeNativeMethods.clLinkProgram(NOpenCL.SafeHandles.ContextSafeHandle,System.UInt32,NOpenCL.UnsafeNativeMethods.ClDeviceID[],System.String,System.UInt32,NOpenCL.SafeHandles.ProgramSafeHandle[],NOpenCL.UnsafeNativeMethods.BuildProgramCallback,System.IntPtr,NOpenCL.UnsafeNativeMethods.ErrorCode@)"/> whichever was performed last on the specified program object for device generated an error.</item>
             <item><see cref="F:NOpenCL.BuildStatus.Success"/>. The build status returned if <see cref="M:NOpenCL.UnsafeNativeMethods.clBuildProgram(NOpenCL.SafeHandles.ProgramSafeHandle,System.UInt32,NOpenCL.UnsafeNativeMethods.ClDeviceID[],System.String,NOpenCL.UnsafeNativeMethods.BuildProgramCallback,System.IntPtr)"/>, <see cref="M:NOpenCL.UnsafeNativeMethods.clCompileProgram(NOpenCL.SafeHandles.ProgramSafeHandle,System.UInt32,NOpenCL.UnsafeNativeMethods.ClDeviceID[],System.String,System.UInt32,NOpenCL.SafeHandles.ProgramSafeHandle[],System.String[],NOpenCL.UnsafeNativeMethods.BuildProgramCallback,System.IntPtr)"/> or <see cref="M:NOpenCL.UnsafeNativeMethods.clLinkProgram(NOpenCL.SafeHandles.ContextSafeHandle,System.UInt32,NOpenCL.UnsafeNativeMethods.ClDeviceID[],System.String,System.UInt32,NOpenCL.SafeHandles.ProgramSafeHandle[],NOpenCL.UnsafeNativeMethods.BuildProgramCallback,System.IntPtr,NOpenCL.UnsafeNativeMethods.ErrorCode@)"/> whichever was performed last on the specified program object for device was successful.</item>
             <item><see cref="F:NOpenCL.BuildStatus.InProgress"/>. The build status returned if <see cref="M:NOpenCL.UnsafeNativeMethods.clBuildProgram(NOpenCL.SafeHandles.ProgramSafeHandle,System.UInt32,NOpenCL.UnsafeNativeMethods.ClDeviceID[],System.String,NOpenCL.UnsafeNativeMethods.BuildProgramCallback,System.IntPtr)"/>, <see cref="M:NOpenCL.UnsafeNativeMethods.clCompileProgram(NOpenCL.SafeHandles.ProgramSafeHandle,System.UInt32,NOpenCL.UnsafeNativeMethods.ClDeviceID[],System.String,System.UInt32,NOpenCL.SafeHandles.ProgramSafeHandle[],System.String[],NOpenCL.UnsafeNativeMethods.BuildProgramCallback,System.IntPtr)"/> or <see cref="M:NOpenCL.UnsafeNativeMethods.clLinkProgram(NOpenCL.SafeHandles.ContextSafeHandle,System.UInt32,NOpenCL.UnsafeNativeMethods.ClDeviceID[],System.String,System.UInt32,NOpenCL.SafeHandles.ProgramSafeHandle[],NOpenCL.UnsafeNativeMethods.BuildProgramCallback,System.IntPtr,NOpenCL.UnsafeNativeMethods.ErrorCode@)"/> whichever was performed last on the specified program object for device has not finished.</item>
             </list>
             </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.ProgramBuildInfo.BuildOptions">
            <summary>
            Return the build, compile or link options specified by the options argument in
            <see cref="M:NOpenCL.UnsafeNativeMethods.clBuildProgram(NOpenCL.SafeHandles.ProgramSafeHandle,System.UInt32,NOpenCL.UnsafeNativeMethods.ClDeviceID[],System.String,NOpenCL.UnsafeNativeMethods.BuildProgramCallback,System.IntPtr)"/>, <see cref="M:NOpenCL.UnsafeNativeMethods.clCompileProgram(NOpenCL.SafeHandles.ProgramSafeHandle,System.UInt32,NOpenCL.UnsafeNativeMethods.ClDeviceID[],System.String,System.UInt32,NOpenCL.SafeHandles.ProgramSafeHandle[],System.String[],NOpenCL.UnsafeNativeMethods.BuildProgramCallback,System.IntPtr)"/>, or <see cref="M:NOpenCL.UnsafeNativeMethods.clLinkProgram(NOpenCL.SafeHandles.ContextSafeHandle,System.UInt32,NOpenCL.UnsafeNativeMethods.ClDeviceID[],System.String,System.UInt32,NOpenCL.SafeHandles.ProgramSafeHandle[],NOpenCL.UnsafeNativeMethods.BuildProgramCallback,System.IntPtr,NOpenCL.UnsafeNativeMethods.ErrorCode@)"/>,
            whichever was performed last on program for device.
            <para/>
            If build status of program for device is <see cref="F:NOpenCL.BuildStatus.None"/>, an empty string is returned.
            </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.ProgramBuildInfo.BuildLog">
            <summary>
            Return the build, compile or link log for <see cref="M:NOpenCL.UnsafeNativeMethods.clBuildProgram(NOpenCL.SafeHandles.ProgramSafeHandle,System.UInt32,NOpenCL.UnsafeNativeMethods.ClDeviceID[],System.String,NOpenCL.UnsafeNativeMethods.BuildProgramCallback,System.IntPtr)"/>,
            <see cref="M:NOpenCL.UnsafeNativeMethods.clCompileProgram(NOpenCL.SafeHandles.ProgramSafeHandle,System.UInt32,NOpenCL.UnsafeNativeMethods.ClDeviceID[],System.String,System.UInt32,NOpenCL.SafeHandles.ProgramSafeHandle[],System.String[],NOpenCL.UnsafeNativeMethods.BuildProgramCallback,System.IntPtr)"/>, or <see cref="M:NOpenCL.UnsafeNativeMethods.clLinkProgram(NOpenCL.SafeHandles.ContextSafeHandle,System.UInt32,NOpenCL.UnsafeNativeMethods.ClDeviceID[],System.String,System.UInt32,NOpenCL.SafeHandles.ProgramSafeHandle[],NOpenCL.UnsafeNativeMethods.BuildProgramCallback,System.IntPtr,NOpenCL.UnsafeNativeMethods.ErrorCode@)"/> whichever
            was performed last on program for device.
            <para/>
            If build status of program for device is <see cref="F:NOpenCL.BuildStatus.None"/>, an empty string is returned.
            </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.ProgramBuildInfo.BinaryType">
             <summary>
             Return the program binary type for device. This can be one of the following values:
            
             <list type="bullet">
             <item><see cref="F:NOpenCL.BinaryType.None"/>. There is no binary associated with device.</item>
             <item><see cref="F:NOpenCL.BinaryType.CompiledObject"/>. A compiled binary is associated with device. This is the case if program was created using <see cref="M:NOpenCL.UnsafeNativeMethods.clCreateProgramWithSource(NOpenCL.SafeHandles.ContextSafeHandle,System.UInt32,System.String[],System.IntPtr[],NOpenCL.UnsafeNativeMethods.ErrorCode@)"/> and compiled using <see cref="M:NOpenCL.UnsafeNativeMethods.clCompileProgram(NOpenCL.SafeHandles.ProgramSafeHandle,System.UInt32,NOpenCL.UnsafeNativeMethods.ClDeviceID[],System.String,System.UInt32,NOpenCL.SafeHandles.ProgramSafeHandle[],System.String[],NOpenCL.UnsafeNativeMethods.BuildProgramCallback,System.IntPtr)"/> or a compiled binary is loaded using <see cref="M:NOpenCL.UnsafeNativeMethods.clCreateProgramWithBinary(NOpenCL.SafeHandles.ContextSafeHandle,System.UInt32,NOpenCL.UnsafeNativeMethods.ClDeviceID[],System.IntPtr[],System.IntPtr[],NOpenCL.UnsafeNativeMethods.ErrorCode[],NOpenCL.UnsafeNativeMethods.ErrorCode@)"/>.</item>
             <item><see cref="F:NOpenCL.BinaryType.Library"/>. A library binary is associated with device. This is the case if program was created by <see cref="M:NOpenCL.UnsafeNativeMethods.clLinkProgram(NOpenCL.SafeHandles.ContextSafeHandle,System.UInt32,NOpenCL.UnsafeNativeMethods.ClDeviceID[],System.String,System.UInt32,NOpenCL.SafeHandles.ProgramSafeHandle[],NOpenCL.UnsafeNativeMethods.BuildProgramCallback,System.IntPtr,NOpenCL.UnsafeNativeMethods.ErrorCode@)"/> which is called with the <c>–createlibrary</c> link option or if a library binary is loaded using <see cref="M:NOpenCL.UnsafeNativeMethods.clCreateProgramWithBinary(NOpenCL.SafeHandles.ContextSafeHandle,System.UInt32,NOpenCL.UnsafeNativeMethods.ClDeviceID[],System.IntPtr[],System.IntPtr[],NOpenCL.UnsafeNativeMethods.ErrorCode[],NOpenCL.UnsafeNativeMethods.ErrorCode@)"/>.</item>
             <item><see cref="F:NOpenCL.BinaryType.Executable"/>. An executable binary is associated with device. This is the case if program was created by <see cref="M:NOpenCL.UnsafeNativeMethods.clLinkProgram(NOpenCL.SafeHandles.ContextSafeHandle,System.UInt32,NOpenCL.UnsafeNativeMethods.ClDeviceID[],System.String,System.UInt32,NOpenCL.SafeHandles.ProgramSafeHandle[],NOpenCL.UnsafeNativeMethods.BuildProgramCallback,System.IntPtr,NOpenCL.UnsafeNativeMethods.ErrorCode@)"/> without the <c>–createlibrary</c> link option or program was created by <see cref="M:NOpenCL.UnsafeNativeMethods.clBuildProgram(NOpenCL.SafeHandles.ProgramSafeHandle,System.UInt32,NOpenCL.UnsafeNativeMethods.ClDeviceID[],System.String,NOpenCL.UnsafeNativeMethods.BuildProgramCallback,System.IntPtr)"/> or an executable binary is loaded using <see cref="M:NOpenCL.UnsafeNativeMethods.clCreateProgramWithBinary(NOpenCL.SafeHandles.ContextSafeHandle,System.UInt32,NOpenCL.UnsafeNativeMethods.ClDeviceID[],System.IntPtr[],System.IntPtr[],NOpenCL.UnsafeNativeMethods.ErrorCode[],NOpenCL.UnsafeNativeMethods.ErrorCode@)"/>.</item>
             </list>
             </summary>
        </member>
        <member name="M:NOpenCL.UnsafeNativeMethods.clCreateSampler(NOpenCL.SafeHandles.ContextSafeHandle,System.Boolean,NOpenCL.AddressingMode,NOpenCL.FilterMode,NOpenCL.UnsafeNativeMethods.ErrorCode@)">
             <summary>
             Creates a sampler object.
             http://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/clCreateSampler.html
             http://www.khronos.org/registry/cl/specs/opencl-1.2.pdf#page=128
             </summary>
             <remarks>
             A sampler object describes how to sample an image when the image is read in the kernel.
             The built-in functions to read from an image in a kernel take a sampler as an argument.
             The sampler arguments to the image read function can be sampler objects created using
             OpenCL functions and passed as argument values to the kernel or can be samplers declared
             inside a kernel. In this section we discuss how sampler objects are created using OpenCL
             functions.
            
             <para>For more information about working with samplers, see <see cref="T:NOpenCL.Sampler"/>.</para>
             </remarks>
             <param name="context">Must be a valid OpenCL context.</param>
             <param name="normalizedCoordinates">Determines if the image coordinates specified are normalized (if <paramref name="normalizedCoordinates"/> is <c>true</c>) or not (if <paramref name="normalizedCoordinates"/> is <c>false</c>).</param>
             <param name="addressingMode">Specifies how out-of-range image coordinates are handled when
             reading from an image. This can be set to <see cref="F:NOpenCL.AddressingMode.MirroredRepeat"/>,
             <see cref="F:NOpenCL.AddressingMode.Repeat"/>, <see cref="F:NOpenCL.AddressingMode.ClampToEdge"/>,
             <see cref="F:NOpenCL.AddressingMode.Clamp"/>, and <see cref="F:NOpenCL.AddressingMode.None"/>.</param>
             <param name="filterMode">Specifies the type of filter that must be applied when reading an image.
             This can be <see cref="F:NOpenCL.FilterMode.Nearest"/> or <see cref="F:NOpenCL.FilterMode.Linear"/>.</param>
             <param name="errorCode">Returns an appropriate error code.</param>
             <returns>Returns a valid non-zero sampler object and <paramref name="errorCode"/> is
             set to <see cref="F:NOpenCL.UnsafeNativeMethods.ErrorCode.Success"/> if the sampler object is created successfully.
             Otherwise, it returns an invalid handle value with one of the following error values
             returned in <paramref name="errorCode"/>:
            
             <list type="bullet">
             <item><see cref="F:NOpenCL.UnsafeNativeMethods.ErrorCode.InvalidContext"/> if <paramref name="context"/> is not a valid context.</item>
             <item><see cref="F:NOpenCL.UnsafeNativeMethods.ErrorCode.InvalidValue"/> if <paramref name="addressingMode"/>, <paramref name="filterMode"/>, or <paramref name="normalizedCoordinates"/> or a combination of these argument values are not valid.</item>
             <item><see cref="F:NOpenCL.UnsafeNativeMethods.ErrorCode.InvalidOperation"/> if images are not supported by any device associated with <paramref name="context"/> (i.e. <see cref="F:NOpenCL.UnsafeNativeMethods.DeviceInfo.ImageSupport"/> specified in the table of OpenCL Device Queries for <see cref="M:NOpenCL.UnsafeNativeMethods.GetDeviceInfo``1(NOpenCL.UnsafeNativeMethods.ClDeviceID,NOpenCL.UnsafeNativeMethods.DeviceParameterInfo{``0})"/> is <c>false</c>).</item>
             <item><see cref="F:NOpenCL.UnsafeNativeMethods.ErrorCode.OutOfResources"/> if there is a failure to allocate resources required by the OpenCL implementation on the device.</item>
             <item><see cref="F:NOpenCL.UnsafeNativeMethods.ErrorCode.OutOfHostMemory"/> if there is a failure to allocate resources required by the OpenCL implementation on the host.</item>
             </list>
             </returns>
        </member>
        <member name="M:NOpenCL.UnsafeNativeMethods.clRetainSampler(NOpenCL.SafeHandles.SamplerSafeHandle)">
             <summary>
             Increments the sampler reference count.
             http://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/clRetainSampler.html
             http://www.khronos.org/registry/cl/specs/opencl-1.2.pdf#page=129
             </summary>
             <remarks>
             <see cref="M:NOpenCL.UnsafeNativeMethods.clCreateSampler(NOpenCL.SafeHandles.ContextSafeHandle,System.Boolean,NOpenCL.AddressingMode,NOpenCL.FilterMode,NOpenCL.UnsafeNativeMethods.ErrorCode@)"/> performs an implicit retain.
             </remarks>
             <param name="sampler">Specifies the sampler being retained.</param>
             <returns>
             Returns <see cref="F:NOpenCL.UnsafeNativeMethods.ErrorCode.Success"/> if the function is executed successfully.
             Otherwise, it returns one of the following errors:
            
             <list type="bullet">
             <item><see cref="F:NOpenCL.UnsafeNativeMethods.ErrorCode.InvalidSampler"/> if sampler is not a valid sampler object.</item>
             <item><see cref="F:NOpenCL.UnsafeNativeMethods.ErrorCode.OutOfResources"/> if there is a failure to allocate resources required by the OpenCL implementation on the device.</item>
             <item><see cref="F:NOpenCL.UnsafeNativeMethods.ErrorCode.OutOfHostMemory"/> if there is a failure to allocate resources required by the OpenCL implementation on the host.</item>
             </list>
             </returns>
        </member>
        <member name="M:NOpenCL.UnsafeNativeMethods.clReleaseSampler(System.IntPtr)">
             <summary>
             Decrements the sampler reference count.
             http://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/clReleaseSampler.html
             http://www.khronos.org/registry/cl/specs/opencl-1.2.pdf#page=129
             </summary>
             <remarks>
             The sampler object is deleted after the reference count
             becomes zero and commands queued for execution on a command-queue(s) that
             use <paramref name="sampler"/> have finished.
             </remarks>
             <param name="sampler">Specifies the sampler being retained.</param>
             <returns>
             Returns <see cref="F:NOpenCL.UnsafeNativeMethods.ErrorCode.Success"/> if the function is executed successfully.
             Otherwise, it returns one of the following errors:
            
             <list type="bullet">
             <item><see cref="F:NOpenCL.UnsafeNativeMethods.ErrorCode.InvalidSampler"/> if sampler is not a valid sampler object.</item>
             <item><see cref="F:NOpenCL.UnsafeNativeMethods.ErrorCode.OutOfResources"/> if there is a failure to allocate resources required by the OpenCL implementation on the device.</item>
             <item><see cref="F:NOpenCL.UnsafeNativeMethods.ErrorCode.OutOfHostMemory"/> if there is a failure to allocate resources required by the OpenCL implementation on the host.</item>
             </list>
             </returns>
        </member>
        <member name="M:NOpenCL.UnsafeNativeMethods.clGetSamplerInfo(NOpenCL.SafeHandles.SamplerSafeHandle,System.Int32,System.UIntPtr,System.IntPtr,System.UIntPtr@)">
             <summary>
             Returns information about the sampler object.
             http://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/clGetSamplerInfo.html
             http://www.khronos.org/registry/cl/specs/opencl-1.2.pdf#page=130
             </summary>
             <param name="sampler">Specifies the sampler being queried.</param>
             <param name="paramName">Specifies the information to query. See the members of <see cref="T:NOpenCL.UnsafeNativeMethods.SamplerInfo"/> for the supported values.</param>
             <param name="paramValueSize">Specifies the size in bytes of memory pointed to by <paramref name="paramValue"/>. This size must be ≥ size of return type as described in the table above.</param>
             <param name="paramValue">A pointer to memory where the appropriate result being queried is returned. If <paramref name="paramValue"/> is <see cref="F:System.IntPtr.Zero"/>, it is ignored.</param>
             <param name="paramValueSizeRet">Returns the actual size in bytes of data copied to <paramref name="paramValue"/>.</param>
             <returns>
             Returns <see cref="F:NOpenCL.UnsafeNativeMethods.ErrorCode.Success"/> if the function is executed successfully.
             Otherwise, it returns one of the following errors:
            
             <list type="bullet">
             <item><see cref="F:NOpenCL.UnsafeNativeMethods.ErrorCode.InvalidValue"/> if <paramref name="paramName"/> is not valid, or if size in bytes specified by <paramref name="paramValueSize"/> is &lt; size of return type as described in the <see cref="T:NOpenCL.UnsafeNativeMethods.SamplerInfo"/> documentation and <paramref name="paramValue"/> is not <see cref="F:System.IntPtr.Zero"/>.</item>
             <item><see cref="F:NOpenCL.UnsafeNativeMethods.ErrorCode.InvalidSampler"/> if <paramref name="sampler"/> is a not a valid sampler object.</item>
             <item><see cref="F:NOpenCL.UnsafeNativeMethods.ErrorCode.OutOfResources"/> if there is a failure to allocate resources required by the OpenCL implementation on the device.</item>
             <item><see cref="F:NOpenCL.UnsafeNativeMethods.ErrorCode.OutOfHostMemory"/> if there is a failure to allocate resources required by the OpenCL implementation on the host.</item>
             </list>
             </returns>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.SamplerInfo.ReferenceCount">
            <summary>
            Return the sampler reference count. The reference count returned should be
            considered immediately stale. It is unsuitable for general use in applications.
            This feature is provided for identifying memory leaks.
            </summary>
            <seealso cref="P:NOpenCL.Sampler.ReferenceCount"/>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.SamplerInfo.Context">
            <summary>
            Return the context specified when the sampler is created.
            </summary>
            <seealso cref="P:NOpenCL.Sampler.Context"/>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.SamplerInfo.NormalizedCoordinates">
            <summary>
            Return the normalized coords value associated with sampler.
            </summary>
            <seealso cref="P:NOpenCL.Sampler.NormalizedCoordinates"/>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.SamplerInfo.AddressingMode">
            <summary>
            Return the addressing mode value associated with sampler.
            </summary>
            <seealso cref="P:NOpenCL.Sampler.AddressingMode"/>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.SamplerInfo.FilterMode">
            <summary>
            Return the filter mode value associated with sampler.
            </summary>
            <seealso cref="P:NOpenCL.Sampler.FilterMode"/>
        </member>
        <member name="M:NOpenCL.UnsafeNativeMethods.clCreateBuffer(NOpenCL.SafeHandles.ContextSafeHandle,NOpenCL.MemoryFlags,System.IntPtr,System.IntPtr,NOpenCL.UnsafeNativeMethods.ErrorCode@)">
             <summary>
             Creates a buffer object.
             http://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/clCreateBuffer.html
             http://www.khronos.org/registry/cl/specs/opencl-1.2.pdf#page=66
             </summary>
             <param name="context">A valid OpenCL context used to create the buffer object.</param>
             <param name="flags">A bit-field that is used to specify allocation and usage information such as the memory arena that should be used to allocate the buffer object and how it will be used. If value specified for flags is <see cref="F:NOpenCL.MemoryFlags.None"/>, the default is used which is <see cref="F:NOpenCL.MemoryFlags.ReadWrite"/>.</param>
             <param name="size">The size in bytes of the buffer memory object to be allocated.</param>
             <param name="hostPointer">A pointer to the buffer data that may already be allocated by the application. The size of the buffer that <paramref name="hostPointer"/> points to must be ≥ <paramref name="size"/> bytes.</param>
             <param name="errorCode">Returns an appropriate error code.</param>
             <returns>
             Returns a valid non-zero buffer object and <paramref name="errorCode"/> is
             set to <see cref="F:NOpenCL.UnsafeNativeMethods.ErrorCode.Success"/> if the buffer object is created
             successfully. Otherwise, it returns an invalid handle with one of the
             following error values returned in <paramref name="errorCode"/>:
            
             <list type="bullet">
             <item><see cref="F:NOpenCL.UnsafeNativeMethods.ErrorCode.InvalidContext"/> if <paramref name="context"/> is not a valid context.</item>
             <item><see cref="F:NOpenCL.UnsafeNativeMethods.ErrorCode.InvalidValue"/> if values specified in <paramref name="flags"/> are not valid.</item>
             <item><see cref="F:NOpenCL.UnsafeNativeMethods.ErrorCode.InvalidBufferSize"/> if <paramref name="size"/> is <see cref="F:System.IntPtr.Zero"/>. Implementations may return <see cref="F:NOpenCL.UnsafeNativeMethods.ErrorCode.InvalidBufferSize"/> if <paramref name="size"/> is greater than the <see cref="F:NOpenCL.UnsafeNativeMethods.DeviceInfo.MaxMemoryAllocationSize"/> value <see cref="M:NOpenCL.UnsafeNativeMethods.GetDeviceInfo``1(NOpenCL.UnsafeNativeMethods.ClDeviceID,NOpenCL.UnsafeNativeMethods.DeviceParameterInfo{``0})"/> for all devices in <paramref name="context"/>.</item>
             <item><see cref="F:NOpenCL.UnsafeNativeMethods.ErrorCode.InvalidHostPtr"/> if <paramref name="hostPointer"/> is <see cref="F:System.IntPtr.Zero"/> and <see cref="F:NOpenCL.MemoryFlags.UseHostPointer"/> or <see cref="F:NOpenCL.MemoryFlags.CopyHostPointer"/> are set in <paramref name="flags"/> or if <paramref name="hostPointer"/> is not <see cref="F:System.IntPtr.Zero"/> but <see cref="F:NOpenCL.MemoryFlags.CopyHostPointer"/> or <see cref="F:NOpenCL.MemoryFlags.UseHostPointer"/> are not set in <paramref name="flags"/>.</item>
             <item><see cref="F:NOpenCL.UnsafeNativeMethods.ErrorCode.MemObjectAllocationFailure"/> if there is a failure to allocate memory for buffer object.</item>
             <item><see cref="F:NOpenCL.UnsafeNativeMethods.ErrorCode.OutOfResources"/> if there is a failure to allocate resources required by the OpenCL implementation on the device.</item>
             <item><see cref="F:NOpenCL.UnsafeNativeMethods.ErrorCode.OutOfHostMemory"/> if there is a failure to allocate resources required by the OpenCL implementation on the host.</item>
             </list>
             </returns>
        </member>
        <member name="M:NOpenCL.UnsafeNativeMethods.clCreateSubBuffer(NOpenCL.SafeHandles.BufferSafeHandle,NOpenCL.MemoryFlags,NOpenCL.BufferCreateType,NOpenCL.BufferRegion@,NOpenCL.UnsafeNativeMethods.ErrorCode@)">
             <summary>
             Creates a new buffer object (referred to as a sub-buffer object) from an existing buffer object.
             http://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/clCreateSubBuffer.html
             http://www.khronos.org/registry/cl/specs/opencl-1.2.pdf#page=69
             </summary>
             <param name="buffer">A valid object and cannot be a sub-buffer object.</param>
             <param name="flags">A bit-field that is used to specify allocation and usage information about the sub-buffer memory object being created.</param>
             <param name="mustBeRegion">Must be <see cref="F:NOpenCL.BufferCreateType.Region"/>.</param>
             <param name="regionInfo">A <see cref="T:NOpenCL.BufferRegion"/> instance defining the region in
             <paramref name="buffer"/> for which to create a sub-buffer.</param>
             <param name="errorCode">Returns an appropriate error code.</param>
             <returns>
             Returns a valid non-zero buffer object and <paramref name="errorCode"/> is set
             to <see cref="F:NOpenCL.UnsafeNativeMethods.ErrorCode.Success"/> if the buffer object is created successfully.
             Otherwise, it returns an invalid handle with one of the following errors in
             <paramref name="errorCode"/>:
            
             <list type="bullet">
             <item><see cref="F:NOpenCL.UnsafeNativeMethods.ErrorCode.InvalidMemObject"/> if <paramref name="buffer"/> is not a valid buffer object or is a sub-buffer object.</item>
             <item><see cref="F:NOpenCL.UnsafeNativeMethods.ErrorCode.InvalidValue"/> if <paramref name="buffer"/> was created with <see cref="F:NOpenCL.MemoryFlags.WriteOnly"/> and <paramref name="flags"/> specifies <see cref="F:NOpenCL.MemoryFlags.ReadWrite"/> or <see cref="F:NOpenCL.MemoryFlags.ReadOnly"/>, or if <paramref name="buffer"/> was created with <see cref="F:NOpenCL.MemoryFlags.ReadOnly"/> and <paramref name="flags"/> specifies <see cref="F:NOpenCL.MemoryFlags.ReadWrite"/> or <see cref="F:NOpenCL.MemoryFlags.WriteOnly"/>, or if <paramref name="flags"/> specifies <see cref="F:NOpenCL.MemoryFlags.UseHostPointer"/> or <see cref="F:NOpenCL.MemoryFlags.AllocateHostPointer"/> or <see cref="F:NOpenCL.MemoryFlags.CopyHostPointer"/>.</item>
             <item><see cref="F:NOpenCL.UnsafeNativeMethods.ErrorCode.InvalidValue"/> if <paramref name="buffer"/> was created with <see cref="F:NOpenCL.MemoryFlags.HostWriteOnly"/> and <paramref name="flags"/> specifies <see cref="F:NOpenCL.MemoryFlags.HostReadOnly"/> or if <paramref name="buffer"/> was created with <see cref="F:NOpenCL.MemoryFlags.HostReadOnly"/> and <paramref name="flags"/> specifies <see cref="F:NOpenCL.MemoryFlags.HostWriteOnly"/>, or if <paramref name="buffer"/> was created with <see cref="F:NOpenCL.MemoryFlags.HostNoAccess"/> and <paramref name="flags"/> specifies <see cref="F:NOpenCL.MemoryFlags.HostReadOnly"/> or <see cref="F:NOpenCL.MemoryFlags.HostWriteOnly"/>.</item>
             <item><see cref="F:NOpenCL.UnsafeNativeMethods.ErrorCode.InvalidValue"/> if value specified in <paramref name="mustBeRegion"/> is not valid.</item>
             <item><see cref="F:NOpenCL.UnsafeNativeMethods.ErrorCode.InvalidValue"/> if value(s) specified in <paramref name="regionInfo"/> (for a given <paramref name="mustBeRegion"/>) is not valid.</item>
             <item><see cref="F:NOpenCL.UnsafeNativeMethods.ErrorCode.InvalidBufferSize"/> if <see cref="F:NOpenCL.BufferRegion.Size"/> is <see cref="F:System.IntPtr.Zero"/>.</item>
             <item><see cref="F:NOpenCL.UnsafeNativeMethods.ErrorCode.MemObjectAllocationFailure"/> if there is a failure to allocate memory for sub-buffer object.</item>
             <item><see cref="F:NOpenCL.UnsafeNativeMethods.ErrorCode.OutOfResources"/> if there is a failure to allocate resources required by the OpenCL implementation on the device.</item>
             <item><see cref="F:NOpenCL.UnsafeNativeMethods.ErrorCode.OutOfHostMemory"/> if there is a failure to allocate resources required by the OpenCL implementation on the host.</item>
             </list>
             </returns>
        </member>
        <member name="M:NOpenCL.UnsafeNativeMethods.clEnqueueReadBuffer(NOpenCL.SafeHandles.CommandQueueSafeHandle,NOpenCL.SafeHandles.BufferSafeHandle,System.Boolean,System.IntPtr,System.IntPtr,System.IntPtr,System.UInt32,NOpenCL.SafeHandles.EventSafeHandle[],NOpenCL.SafeHandles.EventSafeHandle@)">
             <summary>
             Enqueue commands to read from a buffer object to host memory.
             http://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/clEnqueueReadBuffer.html
             http://www.khronos.org/registry/cl/specs/opencl-1.2.pdf#page=72
             </summary>
             <remarks>
             Calling <see cref="M:NOpenCL.UnsafeNativeMethods.clEnqueueReadBuffer(NOpenCL.SafeHandles.CommandQueueSafeHandle,NOpenCL.SafeHandles.BufferSafeHandle,System.Boolean,System.IntPtr,System.IntPtr,System.IntPtr,System.UInt32,NOpenCL.SafeHandles.EventSafeHandle[],NOpenCL.SafeHandles.EventSafeHandle@)"/> to read a region of the buffer object with
             the <paramref name="destination"/> argument value set to <em>hostPointer</em> + <paramref name="offset"/>,
             where <em>hostPointer</em> is a pointer to the memory region specified when the buffer
             object being read is created with <see cref="F:NOpenCL.MemoryFlags.UseHostPointer"/>, must meet
             the following requirements in order to avoid undefined behavior:
            
             <list type="bullet">
             <item>All commands that use this buffer object or a memory object (buffer or image) created from this buffer object have finished execution before the read command begins execution.</item>
             <item>The buffer object or memory objects created from this buffer object are not mapped.</item>
             <item>The buffer object or memory objects created from this buffer object are not used by any command-queue until the read command has finished execution.</item>
             </list>
             </remarks>
             <param name="commandQueue">Refers to the command-queue in which the read command will be queued. <paramref name="commandQueue"/> and <paramref name="buffer"/> must be created with the same OpenCL context.</param>
             <param name="buffer">Refers to a valid buffer object.</param>
             <param name="blockingRead">
             Indicates if the read operations are blocking or non-blocking.
            
             <para>If <paramref name="blockingRead"/> is <c>true</c> i.e. the read command is blocking, <see cref="M:NOpenCL.UnsafeNativeMethods.clEnqueueReadBuffer(NOpenCL.SafeHandles.CommandQueueSafeHandle,NOpenCL.SafeHandles.BufferSafeHandle,System.Boolean,System.IntPtr,System.IntPtr,System.IntPtr,System.UInt32,NOpenCL.SafeHandles.EventSafeHandle[],NOpenCL.SafeHandles.EventSafeHandle@)"/> does not return until the buffer data has been read and copied into memory pointed to by <paramref name="destination"/>.</para>
            
             <para>If <paramref name="blockingRead"/> is <c>false</c> i.e. the read command is non-blocking, <see cref="M:NOpenCL.UnsafeNativeMethods.clEnqueueReadBuffer(NOpenCL.SafeHandles.CommandQueueSafeHandle,NOpenCL.SafeHandles.BufferSafeHandle,System.Boolean,System.IntPtr,System.IntPtr,System.IntPtr,System.UInt32,NOpenCL.SafeHandles.EventSafeHandle[],NOpenCL.SafeHandles.EventSafeHandle@)"/> queues a non-blocking read command and returns. The contents of the buffer that <paramref name="destination"/> points to cannot be used until the read command has completed. The <paramref name="event"/> argument returns an event object which can be used to query the execution status of the read command. When the read command has completed, the contents of the buffer that <paramref name="destination"/> points to can be used by the application.</para>
             </param>
             <param name="offset">The offset in bytes in the buffer object to read from.</param>
             <param name="size">The size in bytes of data being read.</param>
             <param name="destination">The pointer to buffer in host memory where data is to be read into.</param>
             <param name="numEventsInWaitList">The number of events in <paramref name="eventWaitList"/>.</param>
             <param name="eventWaitList">The events that need to complete before this particular command can be executed.
             If <paramref name="eventWaitList"/> is <see langword="null"/>, then this particular command does not wait on
             any event to complete. If <paramref name="eventWaitList"/> is <see langword="null"/>,
             <paramref name="numEventsInWaitList"/> must be 0. If <paramref name="eventWaitList"/> is not
             <see langword="null"/>, the list of events pointed to by <paramref name="eventWaitList"/> must be valid and
             <paramref name="numEventsInWaitList"/> must be greater than 0.</param>
             <param name="event">Returns an event object that identifies this particular read command and can be used to query or queue a wait for this particular command to complete.</param>
             <returns>
             <see cref="M:NOpenCL.UnsafeNativeMethods.clEnqueueReadBuffer(NOpenCL.SafeHandles.CommandQueueSafeHandle,NOpenCL.SafeHandles.BufferSafeHandle,System.Boolean,System.IntPtr,System.IntPtr,System.IntPtr,System.UInt32,NOpenCL.SafeHandles.EventSafeHandle[],NOpenCL.SafeHandles.EventSafeHandle@)"/> returns <see cref="F:NOpenCL.UnsafeNativeMethods.ErrorCode.Success"/> if the function
             is executed successfully. Otherwise, it returns one of the following errors:
            
             <list type="bullet">
             <item><see cref="F:NOpenCL.UnsafeNativeMethods.ErrorCode.InvalidCommandQueue"/> if <paramref name="commandQueue"/> is not a valid command-queue.</item>
             <item><see cref="F:NOpenCL.UnsafeNativeMethods.ErrorCode.InvalidContext"/> if the context associated with <paramref name="commandQueue"/> and <paramref name="buffer"/> are not the same or if the context associated with <paramref name="commandQueue"/> and events in <paramref name="eventWaitList"/> are not the same.</item>
             <item><see cref="F:NOpenCL.UnsafeNativeMethods.ErrorCode.InvalidMemObject"/> if <paramref name="buffer"/> is not a valid buffer object.</item>
             <item><see cref="F:NOpenCL.UnsafeNativeMethods.ErrorCode.InvalidValue"/> if the region being read specified by (<paramref name="offset"/>, <paramref name="size"/>) is out of bounds or if <paramref name="destination"/> is <see cref="F:System.IntPtr.Zero"/> or if <paramref name="size"/> is 0.</item>
             <item><see cref="F:NOpenCL.UnsafeNativeMethods.ErrorCode.InvalidEventWaitList"/> if <paramref name="eventWaitList"/> is <c>null</c> and <paramref name="numEventsInWaitList"/> greater than 0, or <paramref name="eventWaitList"/> is not <c>null</c> and <paramref name="numEventsInWaitList"/> is 0, or if event objects in <paramref name="eventWaitList"/> are not valid events.</item>
             <item><see cref="F:NOpenCL.UnsafeNativeMethods.ErrorCode.MisalignedSubBufferOffset"/> if <paramref name="buffer"/> is a sub-buffer object and <paramref name="offset"/> specified when the sub-buffer object is created is not aligned to <see cref="F:NOpenCL.UnsafeNativeMethods.DeviceInfo.MemoryBaseAddressAlignment"/> value for device associated with <paramref name="commandQueue"/>.</item>
             <item><see cref="F:NOpenCL.UnsafeNativeMethods.ErrorCode.ExecStatusErrorForEventsInWaitList"/> if the read and write operations are blocking and the <see cref="F:NOpenCL.UnsafeNativeMethods.EventInfo.CommandExecutionStatus"/> of any of the events in <paramref name="eventWaitList"/> is a negative integer value.</item>
             <item><see cref="F:NOpenCL.UnsafeNativeMethods.ErrorCode.MemObjectAllocationFailure"/> if there is a failure to allocate memory for data store associated with <paramref name="buffer"/>.</item>
             <item><see cref="F:NOpenCL.UnsafeNativeMethods.ErrorCode.InvalidOperation"/> if <see cref="M:NOpenCL.UnsafeNativeMethods.clEnqueueReadBuffer(NOpenCL.SafeHandles.CommandQueueSafeHandle,NOpenCL.SafeHandles.BufferSafeHandle,System.Boolean,System.IntPtr,System.IntPtr,System.IntPtr,System.UInt32,NOpenCL.SafeHandles.EventSafeHandle[],NOpenCL.SafeHandles.EventSafeHandle@)"/> is called on <paramref name="buffer"/> which has been created with <see cref="F:NOpenCL.MemoryFlags.HostWriteOnly"/> or <see cref="F:NOpenCL.MemoryFlags.HostNoAccess"/>.</item>
             <item><see cref="F:NOpenCL.UnsafeNativeMethods.ErrorCode.OutOfResources"/> if there is a failure to allocate resources required by the OpenCL implementation on the device.</item>
             <item><see cref="F:NOpenCL.UnsafeNativeMethods.ErrorCode.OutOfHostMemory"/> if there is a failure to allocate resources required by the OpenCL implementation on the host.</item>
             </list>
             </returns>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.MemObjectInfo.Type">
             <summary>
             Returns one of the following values:
            
             <list type="bullet">
             <item><see cref="F:NOpenCL.MemObjectType.Buffer"/> if the memory object was created with <see cref="M:NOpenCL.UnsafeNativeMethods.clCreateBuffer(NOpenCL.SafeHandles.ContextSafeHandle,NOpenCL.MemoryFlags,System.IntPtr,System.IntPtr,NOpenCL.UnsafeNativeMethods.ErrorCode@)"/> or <see cref="M:NOpenCL.UnsafeNativeMethods.clCreateSubBuffer(NOpenCL.SafeHandles.BufferSafeHandle,NOpenCL.MemoryFlags,NOpenCL.BufferCreateType,NOpenCL.BufferRegion@,NOpenCL.UnsafeNativeMethods.ErrorCode@)"/>.</item>
             <item><see cref="F:NOpenCL.ImageDescriptor.Type"/> value if the memory object was created with <see cref="M:NOpenCL.UnsafeNativeMethods.clCreateImage(NOpenCL.SafeHandles.ContextSafeHandle,NOpenCL.MemoryFlags,NOpenCL.ImageFormat@,NOpenCL.ImageDescriptor@,System.IntPtr,NOpenCL.UnsafeNativeMethods.ErrorCode@)"/>.</item>
             </list>
             </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.MemObjectInfo.Flags">
            <summary>
            Returns the <em>flags</em> argument value specified when the memory object was
            created with <see cref="M:NOpenCL.UnsafeNativeMethods.clCreateBuffer(NOpenCL.SafeHandles.ContextSafeHandle,NOpenCL.MemoryFlags,System.IntPtr,System.IntPtr,NOpenCL.UnsafeNativeMethods.ErrorCode@)"/>, <see cref="M:NOpenCL.UnsafeNativeMethods.clCreateSubBuffer(NOpenCL.SafeHandles.BufferSafeHandle,NOpenCL.MemoryFlags,NOpenCL.BufferCreateType,NOpenCL.BufferRegion@,NOpenCL.UnsafeNativeMethods.ErrorCode@)"/>, or
            <see cref="M:NOpenCL.UnsafeNativeMethods.clCreateImage(NOpenCL.SafeHandles.ContextSafeHandle,NOpenCL.MemoryFlags,NOpenCL.ImageFormat@,NOpenCL.ImageDescriptor@,System.IntPtr,NOpenCL.UnsafeNativeMethods.ErrorCode@)"/>. If the memory object is a sub-buffer the memory
            access qualifiers inherited from parent buffer are also returned.
            </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.MemObjectInfo.Size">
            <summary>
            Return actual size of the data store associated with the memory object in bytes.
            </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.MemObjectInfo.HostAddress">
             <summary>
             If the memory object was created with <see cref="M:NOpenCL.UnsafeNativeMethods.clCreateBuffer(NOpenCL.SafeHandles.ContextSafeHandle,NOpenCL.MemoryFlags,System.IntPtr,System.IntPtr,NOpenCL.UnsafeNativeMethods.ErrorCode@)"/> or <see cref="M:NOpenCL.UnsafeNativeMethods.clCreateImage(NOpenCL.SafeHandles.ContextSafeHandle,NOpenCL.MemoryFlags,NOpenCL.ImageFormat@,NOpenCL.ImageDescriptor@,System.IntPtr,NOpenCL.UnsafeNativeMethods.ErrorCode@)"/>
             and <see cref="F:NOpenCL.MemoryFlags.UseHostPointer"/> is specified in <em>memoryFlags</em>, return the
             <em>hostPointer</em> argument value specified when the memory object was created. Otherwise
             <see cref="F:System.IntPtr.Zero"/> is returned.
            
             <para>If the memory object was created with <see cref="M:NOpenCL.UnsafeNativeMethods.clCreateSubBuffer(NOpenCL.SafeHandles.BufferSafeHandle,NOpenCL.MemoryFlags,NOpenCL.BufferCreateType,NOpenCL.BufferRegion@,NOpenCL.UnsafeNativeMethods.ErrorCode@)"/>, return the
             <em>hostPointer</em> + <em>origin</em> value specified when the memory object was created.
             <em>hostPointer</em> is the argument value specified to <see cref="M:NOpenCL.UnsafeNativeMethods.clCreateBuffer(NOpenCL.SafeHandles.ContextSafeHandle,NOpenCL.MemoryFlags,System.IntPtr,System.IntPtr,NOpenCL.UnsafeNativeMethods.ErrorCode@)"/> and
             <see cref="F:NOpenCL.MemoryFlags.UseHostPointer"/> is specified in <em>memoryFlags</em> for memory
             object from which this memory object was created. Otherwise <see cref="F:System.IntPtr.Zero"/> is
             returned.</para>
             </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.MemObjectInfo.MapCount">
            <summary>
            Map count. The map count returned should be considered immediately stale. It is unsuitable
            for general use in applications. This feature is provided for debugging.
            </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.MemObjectInfo.ReferenceCount">
            <summary>
            Return the reference count of the memory object. The reference count returned should be
            considered immediately stale. It is unsuitable for general use in applications. This
            feature is provided for identifying memory leaks.
            </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.MemObjectInfo.Context">
            <summary>
            Return the context specified when the memory object was created. If the memory object was
            created using <see cref="M:NOpenCL.UnsafeNativeMethods.clCreateSubBuffer(NOpenCL.SafeHandles.BufferSafeHandle,NOpenCL.MemoryFlags,NOpenCL.BufferCreateType,NOpenCL.BufferRegion@,NOpenCL.UnsafeNativeMethods.ErrorCode@)"/>, the context associated with the memory
            object specified as the buffer argument to <see cref="M:NOpenCL.UnsafeNativeMethods.clCreateSubBuffer(NOpenCL.SafeHandles.BufferSafeHandle,NOpenCL.MemoryFlags,NOpenCL.BufferCreateType,NOpenCL.BufferRegion@,NOpenCL.UnsafeNativeMethods.ErrorCode@)"/> is returned.
            </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.MemObjectInfo.AssociatedMemObject">
             <summary>
             Return the memory object from which this memory object was created.
            
             <para>This returns the memory object specified as the <em>buffer</em> argument to <see cref="M:NOpenCL.UnsafeNativeMethods.clCreateSubBuffer(NOpenCL.SafeHandles.BufferSafeHandle,NOpenCL.MemoryFlags,NOpenCL.BufferCreateType,NOpenCL.BufferRegion@,NOpenCL.UnsafeNativeMethods.ErrorCode@)"/>.</para>
            
             <para>Otherwise <see cref="F:System.IntPtr.Zero"/> is returned.</para>
             </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.MemObjectInfo.Offset">
            <summary>
            Return offset if the memory object is a sub-buffer object created using
            <see cref="M:NOpenCL.UnsafeNativeMethods.clCreateSubBuffer(NOpenCL.SafeHandles.BufferSafeHandle,NOpenCL.MemoryFlags,NOpenCL.BufferCreateType,NOpenCL.BufferRegion@,NOpenCL.UnsafeNativeMethods.ErrorCode@)"/>. This returns <see cref="F:System.UIntPtr.Zero"/>
            if the memory object is not a sub-buffer object.
            </summary>
        </member>
        <member name="P:NOpenCL.UnsafeNativeMethods.ImageInfo.Format">
            <summary>
            Return <see cref="T:NOpenCL.ImageFormat"/> descriptor specified when the image was created with <see cref="M:NOpenCL.UnsafeNativeMethods.clCreateImage(NOpenCL.SafeHandles.ContextSafeHandle,NOpenCL.MemoryFlags,NOpenCL.ImageFormat@,NOpenCL.ImageDescriptor@,System.IntPtr,NOpenCL.UnsafeNativeMethods.ErrorCode@)"/>.
            </summary>
        </member>
        <member name="P:NOpenCL.UnsafeNativeMethods.ImageInfo.ElementSize">
            <summary>
            Return size of each element of the image memory object. An element is made up of <em>n</em> channels.
            The value of <em>n</em> is given in <see cref="F:NOpenCL.ImageFormat.ChannelOrder"/>.
            </summary>
        </member>
        <member name="P:NOpenCL.UnsafeNativeMethods.ImageInfo.RowPitch">
            <summary>
            Return size in bytes of a row of elements of the image object given by the image.
            </summary>
        </member>
        <member name="P:NOpenCL.UnsafeNativeMethods.ImageInfo.SlicePitch">
            <summary>
            Return calculated slice pitch in bytes of a 2D slice for the 3D image object or
            size of each image in a 1D or 2D image array given by the image. For a 1D image,
            1D image buffer and 2D image object return <see cref="F:System.UIntPtr.Zero"/>.
            </summary>
        </member>
        <member name="P:NOpenCL.UnsafeNativeMethods.ImageInfo.Width">
            <summary>
            Return the width of the image in pixels.
            </summary>
        </member>
        <member name="P:NOpenCL.UnsafeNativeMethods.ImageInfo.Height">
            <summary>
            Return the height of the image in pixels. For a 1D image, 1D image buffer and 1D
            image array object, this returns <see cref="F:System.UIntPtr.Zero"/>.
            </summary>
        </member>
        <member name="P:NOpenCL.UnsafeNativeMethods.ImageInfo.Depth">
            <summary>
            Return the depth of the the image in pixels. For a 1D image, 1D image buffer, 2D
            image or 1D and 2D image array object, this returns <see cref="F:System.UIntPtr.Zero"/>.
            </summary>
        </member>
        <member name="P:NOpenCL.UnsafeNativeMethods.ImageInfo.ArraySize">
            <summary>
            Return number of images in the image array. If the image is not an image array,
            <see cref="F:System.UIntPtr.Zero"/> is returned.
            </summary>
        </member>
        <member name="P:NOpenCL.UnsafeNativeMethods.ImageInfo.Buffer">
            <summary>
            Return the buffer object associated with the image.
            </summary>
        </member>
        <member name="P:NOpenCL.UnsafeNativeMethods.ImageInfo.NumMipLevels">
            <summary>
            Return the <see cref="F:NOpenCL.ImageDescriptor.NumMipLevels"/> associated with the image.
            </summary>
        </member>
        <member name="P:NOpenCL.UnsafeNativeMethods.ImageInfo.NumSamples">
            <summary>
            Return the <see cref="F:NOpenCL.ImageDescriptor.NumSamples"/> associated with the image.
            </summary>
        </member>
        <member name="P:NOpenCL.UnsafeNativeMethods.CommandQueueInfo.Context">
            <summary>
            Return the context specified when the command-queue is created.
            </summary>
            <seealso cref="P:NOpenCL.CommandQueue.Context"/>
        </member>
        <member name="P:NOpenCL.UnsafeNativeMethods.CommandQueueInfo.Device">
            <summary>
            Return the device specified when the command-queue is created.
            </summary>
            <seealso cref="P:NOpenCL.CommandQueue.Device"/>
        </member>
        <member name="P:NOpenCL.UnsafeNativeMethods.CommandQueueInfo.ReferenceCount">
            <summary>
            Return the command-queue reference count.
            </summary>
            <remarks>
            The reference count returned with <see cref="P:NOpenCL.UnsafeNativeMethods.CommandQueueInfo.ReferenceCount"/> should be considered
            immediately stale. It is unsuitable for general use in applications. This feature
            is provided for identifying memory leaks.
            </remarks>
            <seealso cref="P:NOpenCL.CommandQueue.ReferenceCount"/>
        </member>
        <member name="P:NOpenCL.UnsafeNativeMethods.CommandQueueInfo.Properties">
            <summary>
            Return the currently specified properties for the command-queue. These
            properties are specified by the <em>properties</em> argument in <see cref="M:NOpenCL.UnsafeNativeMethods.clCreateCommandQueue(NOpenCL.SafeHandles.ContextSafeHandle,NOpenCL.UnsafeNativeMethods.ClDeviceID,NOpenCL.CommandQueueProperties,NOpenCL.UnsafeNativeMethods.ErrorCode@)"/>.
            </summary>
            <seealso cref="P:NOpenCL.CommandQueue.Properties"/>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.ContextProperties.Platform">
            <summary>
            Specifies the platform to use.
            </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.ContextProperties.InteropUserSync">
            <summary>
            Specifies whether the user is responsible for synchronization between OpenCL and
            other APIs. Please refer to the specific sections in the OpenCL 1.2 extension
            specification that describe sharing with other APIs for restrictions on using
            this flag. If <see cref="F:NOpenCL.UnsafeNativeMethods.ContextProperties.InteropUserSync"/> is not specified, a default of
            <c>false</c> is assumed.
            </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.ContextInfo.ReferenceCount">
            <summary>
            Return the context reference count. The reference count returned should be considered
            immediately stale. It is unsuitable for general use in applications. This feature is
            provided for identifying memory leaks.
            </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.ContextInfo.NumDevices">
            <summary>
            Return the number of devices in context.
            </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.ContextInfo.Devices">
            <summary>
            Return the list of devices in context.
            </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.ContextInfo.Properties">
            <summary>
            Return the properties argument specified in <see cref="M:NOpenCL.UnsafeNativeMethods.clCreateContext(System.IntPtr[],System.UInt32,NOpenCL.UnsafeNativeMethods.ClDeviceID[],NOpenCL.UnsafeNativeMethods.CreateContextCallback,System.IntPtr,NOpenCL.UnsafeNativeMethods.ErrorCode@)"/> or
            <see cref="M:NOpenCL.UnsafeNativeMethods.clCreateContextFromType(System.IntPtr[],NOpenCL.DeviceType,NOpenCL.UnsafeNativeMethods.CreateContextCallback,System.IntPtr,NOpenCL.UnsafeNativeMethods.ErrorCode@)"/>.
            <para/>
            If the properties argument specified in <see cref="M:NOpenCL.UnsafeNativeMethods.clCreateContext(System.IntPtr[],System.UInt32,NOpenCL.UnsafeNativeMethods.ClDeviceID[],NOpenCL.UnsafeNativeMethods.CreateContextCallback,System.IntPtr,NOpenCL.UnsafeNativeMethods.ErrorCode@)"/> or
            <see cref="M:NOpenCL.UnsafeNativeMethods.clCreateContextFromType(System.IntPtr[],NOpenCL.DeviceType,NOpenCL.UnsafeNativeMethods.CreateContextCallback,System.IntPtr,NOpenCL.UnsafeNativeMethods.ErrorCode@)"/> used to create context is not null,
            the implementation must return the values specified in the properties argument.
            <para/>
            If the properties argument specified in <see cref="M:NOpenCL.UnsafeNativeMethods.clCreateContext(System.IntPtr[],System.UInt32,NOpenCL.UnsafeNativeMethods.ClDeviceID[],NOpenCL.UnsafeNativeMethods.CreateContextCallback,System.IntPtr,NOpenCL.UnsafeNativeMethods.ErrorCode@)"/> or
            <see cref="M:NOpenCL.UnsafeNativeMethods.clCreateContextFromType(System.IntPtr[],NOpenCL.DeviceType,NOpenCL.UnsafeNativeMethods.CreateContextCallback,System.IntPtr,NOpenCL.UnsafeNativeMethods.ErrorCode@)"/> used to create context is null, the
            implementation may return either a <em>paramValueSizeRet</em> of 0, i.e. there
            is no context property value to be returned or can return a context property
            value of 0 (where 0 is used to terminate the context properties list) in the
            memory that <em>paramValue</em> points to.
            </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.DeviceInfo.AddressBits">
            <summary>
            The default compute device address space size specified as an unsigned integer
            value in bits. Currently supported values are 32 or 64 bits.
            </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.DeviceInfo.Available">
            <summary>
            Is true if the device is available and false if the device is not available.
            </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.DeviceInfo.BuiltInKernels">
            <summary>
            A semi-colon separated list of built-in kernels supported by the device. An
            empty string is returned if no built-in kernels are supported by the device.
            </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.DeviceInfo.CompilerAvailable">
            <summary>
            Is false if the implementation does not have a compiler available to compile
            the program source. Is true if the compiler is available. This can be false
            for the embedded platform profile only.
            </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.DeviceInfo.DoubleFloatingPointConfiguration">
             <summary>
             Describes double precision floating-point capability of the OpenCL device.
             This is a bit-field that describes one or more of the following values:
            
             <list type="bullet">
             <item><see cref="F:NOpenCL.FloatingPointConfiguration.Denorm"/> - denorms are supported.</item>
             <item><see cref="F:NOpenCL.FloatingPointConfiguration.InfNaN"/> - INF and NaNs are supported.</item>
             <item><see cref="F:NOpenCL.FloatingPointConfiguration.RoundToNearest"/> - round to nearest even rounding mode supported.</item>
             <item><see cref="F:NOpenCL.FloatingPointConfiguration.RoundToZero"/> - round to zero rounding mode supported.</item>
             <item><see cref="F:NOpenCL.FloatingPointConfiguration.RoundToInf"/> - round to positive and negative infinity rounding modes supported.</item>
             <item><see cref="F:NOpenCL.FloatingPointConfiguration.Fma"/> - IEEE754-2008 fused multiply-add is supported.</item>
             <item><see cref="F:NOpenCL.FloatingPointConfiguration.SoftFloat"/> - Basic floating-point operations (such as addition, subtraction, multiplication) are implemented in software.</item>
             </list>
             <para/>
             Double precision is an optional feature so the mandated minimum double
             precision floating-point capability is 0.
             <para/>
             If double precision is supported by the device, then the minimum double
             precision floatingpoint capability must be:
             <c><see cref="F:NOpenCL.FloatingPointConfiguration.Fma"/> | <see cref="F:NOpenCL.FloatingPointConfiguration.RoundToNearest"/> | <see cref="F:NOpenCL.FloatingPointConfiguration.RoundToZero"/> | <see cref="F:NOpenCL.FloatingPointConfiguration.RoundToInf"/> | <see cref="F:NOpenCL.FloatingPointConfiguration.InfNaN"/> | <see cref="F:NOpenCL.FloatingPointConfiguration.Denorm"/></c>
             .
             </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.DeviceInfo.LittleEndian">
            <summary>
            Is true if the OpenCL device is a little endian device and false otherwise.
            </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.DeviceInfo.ErrorCorrectionSupport">
            <summary>
            Is true if the device implements error correction for all accesses to compute
            device memory (global and constant). Is false if the device does not implement
            such error correction.
            </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.DeviceInfo.ExecutionCapabilities">
             <summary>
             Describes the execution capabilities of the device. This is a bit-field that
             describes one or more of the following values:
            
             <list type="bullet">
             <item><see cref="F:NOpenCL.ExecutionCapabilities.Kernel"/> - The OpenCL device can execute OpenCL kernels.</item>
             <item><see cref="F:NOpenCL.ExecutionCapabilities.NativeKernel"/> - The OpenCL device can execute native kernels.</item>
             </list>
            
             The mandated minimum capability is <see cref="F:NOpenCL.ExecutionCapabilities.Kernel"/>.
             </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.DeviceInfo.Extensions">
             <summary>
             Returns a space separated list of extension names (the extension names
             themselves do not contain any spaces) supported by the device. The list
             of extension names returned can be vendor supported extension names and
             one or more of the following Khronos approved extension names:
            
             <list type="bullet">
             <item>cl_khr_int64_base_atomics</item>
             <item>cl_khr_int64_extended_atomics</item>
             <item>cl_khr_fp16</item>
             <item>cl_khr_gl_sharing</item>
             <item>cl_khr_gl_event</item>
             <item>cl_khr_d3d10_sharing</item>
             <item>cl_khr_dx9_media_sharing</item>
             <item>cl_khr_d3d11_sharing</item>
             </list>
             </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.DeviceInfo.GlobalCacheSize">
            <summary>
            Size of global memory cache in bytes.
            </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.DeviceInfo.GlobalCacheType">
            <summary>
            Type of global memory cache supported. Valid values are:
            <see cref="F:NOpenCL.CacheType.None"/>, <see cref="F:NOpenCL.CacheType.ReadOnly"/>,
            and <see cref="F:NOpenCL.CacheType.ReadWrite"/>.
            </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.DeviceInfo.GlobalCacheLineSize">
            <summary>
            Size of global memory cache line in bytes.
            </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.DeviceInfo.GlobalMemorySize">
            <summary>
            Size of global device memory in bytes.
            </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.DeviceInfo.HalfFloatingPointConfiguration">
             <summary>
             Describes the OPTIONAL half precision floating-point capability of the
             OpenCL device. This is a bit-field that describes one or more of the
             following values:
            
             <list type="bullet">
             <item><see cref="F:NOpenCL.FloatingPointConfiguration.Denorm"/> - denorms are supported.</item>
             <item><see cref="F:NOpenCL.FloatingPointConfiguration.InfNaN"/> - INF and NaNs are supported.</item>
             <item><see cref="F:NOpenCL.FloatingPointConfiguration.RoundToNearest"/> - round to nearest even rounding mode supported.</item>
             <item><see cref="F:NOpenCL.FloatingPointConfiguration.RoundToZero"/> - round to zero rounding mode supported.</item>
             <item><see cref="F:NOpenCL.FloatingPointConfiguration.RoundToInf"/> - round to +ve and -ve infinity rounding modes supported.</item>
             <item><see cref="F:NOpenCL.FloatingPointConfiguration.Fma"/> - IEEE754-2008 fused multiply-add is supported.</item>
             <item><see cref="F:NOpenCL.FloatingPointConfiguration.SoftFloat"/> - Basic floating-point operations (such as addition, subtraction, multiplication) are implemented in software.</item>
             </list>
             <para/>
             The required minimum half precision floating-point capability as implemented by this extension is
             <c><see cref="F:NOpenCL.FloatingPointConfiguration.RoundToZero"/></c> or <c><see cref="F:NOpenCL.FloatingPointConfiguration.RoundToInf"/> | <see cref="F:NOpenCL.FloatingPointConfiguration.InfNaN"/></c>
             .
             </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.DeviceInfo.HostUnifiedMemory">
            <summary>
            Is true if the device and the host have a unified memory subsystem and is false otherwise.
            </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.DeviceInfo.ImageSupport">
            <summary>
            Is true if images are supported by the OpenCL device and false otherwise.
            </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.DeviceInfo.Image2DMaxHeight">
            <summary>
            Max height of 2D image in pixels. The minimum value is 8192 if <see cref="F:NOpenCL.UnsafeNativeMethods.DeviceInfo.ImageSupport"/> is true.
            </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.DeviceInfo.Image2DMaxWidth">
            <summary>
            Max width of 2D image or 1D image not created from a buffer object in pixels. The minimum value is 8192 if <see cref="F:NOpenCL.UnsafeNativeMethods.DeviceInfo.ImageSupport"/> is true.
            </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.DeviceInfo.Image3DMaxDepth">
            <summary>
            Max depth of 3D image in pixels. The minimum value is 2048 if <see cref="F:NOpenCL.UnsafeNativeMethods.DeviceInfo.ImageSupport"/> is true.
            </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.DeviceInfo.Image3DMaxHeight">
            <summary>
            Max height of 3D image in pixels. The minimum value is 2048 if <see cref="F:NOpenCL.UnsafeNativeMethods.DeviceInfo.ImageSupport"/> is true.
            </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.DeviceInfo.Image3DMaxWidth">
            <summary>
            Max width of 3D image in pixels. The minimum value is 2048 if <see cref="F:NOpenCL.UnsafeNativeMethods.DeviceInfo.ImageSupport"/> is true.
            </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.DeviceInfo.ImageMaxBufferSize">
            <summary>
            Max number of pixels for a 1D image created from a buffer object. The minimum value is 65536 if <see cref="F:NOpenCL.UnsafeNativeMethods.DeviceInfo.ImageSupport"/> is true.
            </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.DeviceInfo.ImageMaxArraySize">
            <summary>
            Max number of images in a 1D or 2D image array. The minimum value is 2048 if <see cref="F:NOpenCL.UnsafeNativeMethods.DeviceInfo.ImageSupport"/> is true.
            </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.DeviceInfo.LinkerAvailable">
            <summary>
            Is false if the implementation does not have a linker available. Is true
            if the linker is available. This can be false for the embedded platform
            profile only. This must be true if <see cref="F:NOpenCL.UnsafeNativeMethods.DeviceInfo.CompilerAvailable"/> is true.
            </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.DeviceInfo.LocalMemorySize">
            <summary>
            Size of local memory arena in bytes. The minimum value is 32 KB for devices
            that are not of type <see cref="F:NOpenCL.DeviceType.Custom"/>.
            </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.DeviceInfo.LocalMemoryType">
            <summary>
            Type of local memory supported. This can be set to <see cref="F:NOpenCL.LocalMemoryType.Local"/>
            implying dedicated local memory storage such as SRAM, or <see cref="F:NOpenCL.LocalMemoryType.Global"/>.
            For custom devices, <see cref="F:NOpenCL.LocalMemoryType.None"/> can also be returned indicating
            no local memory support.
            </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.DeviceInfo.MaxClockFrequency">
            <summary>
            Maximum configured clock frequency of the device in MHz.
            </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.DeviceInfo.MaxComputeUnits">
            <summary>
            The number of parallel compute units on the OpenCL device. A work-group
            executes on a single compute unit. The minimum value is 1.
            </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.DeviceInfo.MaxConstantArguments">
            <summary>
            Max number of arguments declared with the <c>__constant</c> qualifier in
            a kernel. The minimum value is 8 for devices that are not of type <see cref="F:NOpenCL.DeviceType.Custom"/>.
            </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.DeviceInfo.MaxConstantBufferSize">
            <summary>
            Max size in bytes of a constant buffer allocation. The minimum value is 64
            KB for devices that are not of type <see cref="F:NOpenCL.DeviceType.Custom"/>.
            </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.DeviceInfo.MaxMemoryAllocationSize">
            <summary>
            Max size of memory object allocation in bytes. The minimum value is max
            (1/4th of <see cref="F:NOpenCL.UnsafeNativeMethods.DeviceInfo.GlobalMemorySize"/>, 128*1024*1024) for devices that are
            not of type <see cref="F:NOpenCL.DeviceType.Custom"/>.
            </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.DeviceInfo.MaxParameterSize">
            <summary>
            Max size in bytes of the arguments that can be passed to a kernel. The
            minimum value is 1024 for devices that are not of type <see cref="F:NOpenCL.DeviceType.Custom"/>.
            For this minimum value, only a maximum of 128 arguments can be passed to a kernel.
            </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.DeviceInfo.MaxReadImageArguments">
            <summary>
            Max number of simultaneous image objects that can be read by a kernel.
            The minimum value is 128 if <see cref="F:NOpenCL.UnsafeNativeMethods.DeviceInfo.ImageSupport"/> is true.
            </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.DeviceInfo.MaxSamplers">
            <summary>
            Maximum number of samplers that can be used in a kernel. The minimum value
            is 16 if <see cref="F:NOpenCL.UnsafeNativeMethods.DeviceInfo.ImageSupport"/> is true.
            </summary>
            <seealso cref="T:NOpenCL.Sampler"/>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.DeviceInfo.MaxWorkGroupSize">
            <summary>
            Maximum number of work-items in a work-group executing a kernel on a single
            compute unit, using the data parallel execution model.
            (Refer to <see cref="M:NOpenCL.UnsafeNativeMethods.clEnqueueNDRangeKernel(NOpenCL.SafeHandles.CommandQueueSafeHandle,NOpenCL.SafeHandles.KernelSafeHandle,System.UInt32,System.IntPtr[],System.IntPtr[],System.IntPtr[],System.UInt32,NOpenCL.SafeHandles.EventSafeHandle[],NOpenCL.SafeHandles.EventSafeHandle@)"/>). The minimum value is 1.
            </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.DeviceInfo.MaxWorkItemDimensions">
            <summary>
            Maximum dimensions that specify the global and local work-item IDs used by
            the data parallel execution model. (Refer to <see cref="M:NOpenCL.UnsafeNativeMethods.clEnqueueNDRangeKernel(NOpenCL.SafeHandles.CommandQueueSafeHandle,NOpenCL.SafeHandles.KernelSafeHandle,System.UInt32,System.IntPtr[],System.IntPtr[],System.IntPtr[],System.UInt32,NOpenCL.SafeHandles.EventSafeHandle[],NOpenCL.SafeHandles.EventSafeHandle@)"/>). The
            minimum value is 3 for devices that are not of type <see cref="F:NOpenCL.DeviceType.Custom"/>.
            </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.DeviceInfo.MaxWorkItemSizes">
            <summary>
            Maximum number of work-items that can be specified in each dimension of
            the work-group to <see cref="M:NOpenCL.UnsafeNativeMethods.clEnqueueNDRangeKernel(NOpenCL.SafeHandles.CommandQueueSafeHandle,NOpenCL.SafeHandles.KernelSafeHandle,System.UInt32,System.IntPtr[],System.IntPtr[],System.IntPtr[],System.UInt32,NOpenCL.SafeHandles.EventSafeHandle[],NOpenCL.SafeHandles.EventSafeHandle@)"/>.
            <para/>
            Returns <em>n</em> <see cref="T:System.IntPtr"/> entries, where <em>n</em> is the
            value returned by the query for <see cref="F:NOpenCL.UnsafeNativeMethods.DeviceInfo.MaxWorkItemDimensions"/>.
            <para/>
            The minimum value is (1, 1, 1) for devices that are not of type <see cref="F:NOpenCL.DeviceType.Custom"/>.
            </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.DeviceInfo.MaxWriteImageArguments">
            <summary>
            Max number of simultaneous image objects that can be written to by a
            kernel. The minimum value is 8 if <see cref="F:NOpenCL.UnsafeNativeMethods.DeviceInfo.ImageSupport"/> is true.
            </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.DeviceInfo.MemoryBaseAddressAlignment">
            <summary>
            The minimum value is the size (in bits) of the largest OpenCL built-in
            data type supported by the device (long16 in FULL profile, long16 or
            int16 in EMBEDDED profile) for devices that are not of type <see cref="F:NOpenCL.DeviceType.Custom"/>.
            </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.DeviceInfo.MinDataTypeAlignment">
            <summary>
            Deprecated in OpenCL 1.2. The smallest alignment in bytes which can be
            used for any data type.
            </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.DeviceInfo.Name">
            <summary>
            Device name string.
            </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.DeviceInfo.NativeVectorWidthChar">
            <summary>
            Returns the native ISA vector width. The vector width is defined as
            the number of scalar elements that can be stored in the vector.
            </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.DeviceInfo.NativeVectorWidthShort">
            <summary>
            Returns the native ISA vector width. The vector width is defined as
            the number of scalar elements that can be stored in the vector.
            </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.DeviceInfo.NativeVectorWidthInt">
            <summary>
            Returns the native ISA vector width. The vector width is defined as
            the number of scalar elements that can be stored in the vector.
            </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.DeviceInfo.NativeVectorWidthLong">
            <summary>
            Returns the native ISA vector width. The vector width is defined as
            the number of scalar elements that can be stored in the vector.
            </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.DeviceInfo.NativeVectorWidthFloat">
            <summary>
            Returns the native ISA vector width. The vector width is defined as
            the number of scalar elements that can be stored in the vector.
            </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.DeviceInfo.NativeVectorWidthDouble">
            <summary>
            Returns the native ISA vector width. The vector width is defined as
            the number of scalar elements that can be stored in the vector.
            <para/>
            If double precision is not supported, this must return 0.
            </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.DeviceInfo.NativeVectorWidthHalf">
            <summary>
            Returns the native ISA vector width. The vector width is defined as
            the number of scalar elements that can be stored in the vector.
            <para/>
            If the <c>cl_khr_fp16</c> extension is not supported, this must return 0.
            </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.DeviceInfo.OpenCLVersion">
            <summary>
            OpenCL C version string. Returns the highest OpenCL C version supported
            by the compiler for this device that is not of type <see cref="F:NOpenCL.DeviceType.Custom"/>.
            This version string has the following format:
            <para/>
            <em>OpenCL&lt;space&gt;C&lt;space&gt;&lt;major_version.minor_version&gt;&lt;space&gt;&lt;vendor-specific information&gt;</em>
            <para/>
            The <em>major_version.minor_version</em> value returned must be 1.2 if <see cref="F:NOpenCL.UnsafeNativeMethods.DeviceInfo.Version"/> is OpenCL 1.2.
            <para/>
            The <em>major_version.minor_version</em> value returned must be 1.1 if <see cref="F:NOpenCL.UnsafeNativeMethods.DeviceInfo.Version"/> is OpenCL 1.1.
            </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.DeviceInfo.ParentDevice">
            <summary>
            Returns the <see cref="T:NOpenCL.UnsafeNativeMethods.ClDeviceID"/> of the parent device to which
            this sub-device belongs. If device is a root-level device,
            <see cref="F:System.IntPtr.Zero"/> is returned.
            </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.DeviceInfo.PartitionMaxSubDevices">
            <summary>
            Returns the maximum number of sub-devices that can be created when a
            device is partitioned. The value returned cannot exceed <see cref="F:NOpenCL.UnsafeNativeMethods.DeviceInfo.MaxComputeUnits"/>.
            </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.DeviceInfo.PartitionProperties">
             <summary>
             Returns the list of partition types supported by device. This is an array
             of <see cref="T:NOpenCL.PartitionProperty"/> values drawn from the following list:
            
             <list type="bullet">
             <item><see cref="F:NOpenCL.PartitionProperty.PartitionEqually"/></item>
             <item><see cref="F:NOpenCL.PartitionProperty.PartitionByCounts"/></item>
             <item><see cref="F:NOpenCL.PartitionProperty.PartitionByAffinityDomain"/></item>
             </list>
            
             If the device does not support any partition types, a value of 0 will be returned.
             </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.DeviceInfo.PartitionAffinityDomain">
             <summary>
             Returns the list of supported affinity domains for partitioning the device
             using <see cref="F:NOpenCL.PartitionProperty.PartitionByAffinityDomain"/>. This is a
             bit-field that describes one or more of the following values:
            
             <list type="bullet">
             <item><see cref="F:NOpenCL.AffinityDomain.Numa"/></item>
             <item><see cref="F:NOpenCL.AffinityDomain.L4Cache"/></item>
             <item><see cref="F:NOpenCL.AffinityDomain.L3Cache"/></item>
             <item><see cref="F:NOpenCL.AffinityDomain.L2Cache"/></item>
             <item><see cref="F:NOpenCL.AffinityDomain.L1Cache"/></item>
             <item><see cref="F:NOpenCL.AffinityDomain.NextPartitionable"/></item>
             </list>
            
             If the device does not support any affinity domains, <see cref="F:NOpenCL.AffinityDomain.None"/> will be returned.
             </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.DeviceInfo.PartitionType">
            <summary>
            Returns the properties argument specified in <see cref="M:NOpenCL.UnsafeNativeMethods.clCreateSubDevices(NOpenCL.UnsafeNativeMethods.ClDeviceID,System.IntPtr[],System.UInt32,NOpenCL.UnsafeNativeMethods.ClDeviceID[],System.UInt32@)"/>
            if device is a subdevice. Otherwise the implementation may either return a
            <em>param_value_size_ret</em> of 0 i.e. there is no partition type associated
            with device or can return a property value of 0 (where 0 is used to terminate
            the partition property list) in the memory that <em>param_value</em> points to.
            </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.DeviceInfo.Platform">
            <summary>
            The platform associated with this device.
            </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.DeviceInfo.PreferredVectorWidthChar">
            <summary>
            Preferred native vector width size for built-in scalar types that can be put
            into vectors. The vector width is defined as the number of scalar elements
            that can be stored in the vector.
            </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.DeviceInfo.PreferredVectorWidthShort">
            <summary>
            Preferred native vector width size for built-in scalar types that can be put
            into vectors. The vector width is defined as the number of scalar elements
            that can be stored in the vector.
            </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.DeviceInfo.PreferredVectorWidthInt">
            <summary>
            Preferred native vector width size for built-in scalar types that can be put
            into vectors. The vector width is defined as the number of scalar elements
            that can be stored in the vector.
            </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.DeviceInfo.PreferredVectorWidthLong">
            <summary>
            Preferred native vector width size for built-in scalar types that can be put
            into vectors. The vector width is defined as the number of scalar elements
            that can be stored in the vector.
            </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.DeviceInfo.PreferredVectorWidthFloat">
            <summary>
            Preferred native vector width size for built-in scalar types that can be put
            into vectors. The vector width is defined as the number of scalar elements
            that can be stored in the vector.
            </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.DeviceInfo.PreferredVectorWidthDouble">
            <summary>
            Preferred native vector width size for built-in scalar types that can be put
            into vectors. The vector width is defined as the number of scalar elements
            that can be stored in the vector.
            <para/>
            If double precision is not supported, this must return 0.
            </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.DeviceInfo.PreferredVectorWidthHalf">
            <summary>
            Preferred native vector width size for built-in scalar types that can be put
            into vectors. The vector width is defined as the number of scalar elements
            that can be stored in the vector.
            <para/>
            If the <c>cl_khr_fp16</c> extension is not supported, this must return 0.
            </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.DeviceInfo.PrintfBufferSize">
            <summary>
            Maximum size of the internal buffer that holds the output of printf calls from
            a kernel. The minimum value for the FULL profile is 1 MB.
            </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.DeviceInfo.PreferredInteropUserSync">
            <summary>
            Is true if the device's preference is for the user to be responsible for
            synchronization, when sharing memory objects between OpenCL and other APIs
            such as DirectX, false if the device / implementation has a performant path
            for performing synchronization of memory object shared between OpenCL and
            other APIs such as DirectX.
            </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.DeviceInfo.Profile">
             <summary>
             OpenCL profile string. Returns the profile name supported by the device
             (see note). The profile name returned can be one of the following strings:
            
             <list type="bullet">
             <item>FULL_PROFILE - if the device supports the OpenCL specification (functionality defined as part of the core specification and does not require any extensions to be supported).</item>
             <item>EMBEDDED_PROFILE - if the device supports the OpenCL embedded profile.</item>
             </list>
             </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.DeviceInfo.ProfilingTimerResolution">
            <summary>
            Describes the resolution of device timer. This is measured in nanoseconds.
            </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.DeviceInfo.QueueProperties">
             <summary>
             Describes the command-queue properties supported by the device. This is
             a bit-field that describes one or more of the following values:
            
             <list type="bullet">
             <item><see cref="F:NOpenCL.CommandQueueProperties.OutOfOrderExecutionModeEnable"/></item>
             <item><see cref="F:NOpenCL.CommandQueueProperties.ProfilingEnable"/></item>
             </list>
            
             These properties are described in the table for <see cref="M:NOpenCL.UnsafeNativeMethods.clCreateCommandQueue(NOpenCL.SafeHandles.ContextSafeHandle,NOpenCL.UnsafeNativeMethods.ClDeviceID,NOpenCL.CommandQueueProperties,NOpenCL.UnsafeNativeMethods.ErrorCode@)"/>.
             The mandated minimum capability is <see cref="F:NOpenCL.CommandQueueProperties.ProfilingEnable"/>.
             </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.DeviceInfo.ReferenceCount">
            <summary>
            Returns the device reference count. If the device is a root-level device,
            a reference count of one is returned.
            </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.DeviceInfo.SingleFloatingPointConfiguration">
             <summary>
             Describes single precision floating-point capability of the device.
             This is a bit-field that describes one or more of the following values:
            
             <list type="bullet">
             <item><see cref="F:NOpenCL.FloatingPointConfiguration.Denorm"/> - denorms are supported.</item>
             <item><see cref="F:NOpenCL.FloatingPointConfiguration.InfNaN"/> - INF and quiet NaNs are supported.</item>
             <item><see cref="F:NOpenCL.FloatingPointConfiguration.RoundToNearest"/> - round to nearest even rounding mode supported.</item>
             <item><see cref="F:NOpenCL.FloatingPointConfiguration.RoundToZero"/> - round to zero rounding mode supported.</item>
             <item><see cref="F:NOpenCL.FloatingPointConfiguration.RoundToInf"/> - round to +ve and -ve infinity rounding modes supported.</item>
             <item><see cref="F:NOpenCL.FloatingPointConfiguration.Fma"/> - IEEE754-2008 fused multiply-add is supported.</item>
             <item><see cref="F:NOpenCL.FloatingPointConfiguration.CorrectlyRoundedDivideSqrt"/> - divide and sqrt are correctly rounded as defined by the IEEE754 specification.</item>
             <item><see cref="F:NOpenCL.FloatingPointConfiguration.SoftFloat"/> - Basic floating-point operations (such as addition, subtraction, multiplication) are implemented in software.</item>
             </list>
            
             The mandated minimum floating-point capability for devices that are
             not of type <see cref="F:NOpenCL.DeviceType.Custom"/> is
             <see cref="F:NOpenCL.FloatingPointConfiguration.RoundToNearest"/> |
             <see cref="F:NOpenCL.FloatingPointConfiguration.InfNaN"/>.
             </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.DeviceInfo.DeviceType">
            <summary>
            The OpenCL device type. Currently supported values are one of or a
            combination of: <see cref="F:NOpenCL.DeviceType.Cpu"/>, <see cref="F:NOpenCL.DeviceType.Gpu"/>,
            <see cref="F:NOpenCL.DeviceType.Accelerator"/>, <see cref="F:NOpenCL.DeviceType.Default"/>, a
            combination of the above types, or <see cref="F:NOpenCL.DeviceType.Custom"/>.
            </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.DeviceInfo.Vendor">
            <summary>
            Vendor name string.
            </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.DeviceInfo.VendorID">
            <summary>
            A unique device vendor identifier. An example of a unique device identifier
            could be the PCIe ID.
            </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.DeviceInfo.Version">
            <summary>
            OpenCL version string. Returns the OpenCL version supported by the device.
            This version string has the following format:
            <para/>
            <em>OpenCL&lt;space&gt;&lt;major_version.minor_version&gt;&lt;space&gt;&lt;vendor-specific information&gt;</em>
            <para/>
            The <em>major_version.minor_version</em> value returned will be 1.1.
            </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.DeviceInfo.DriverVersion">
            <summary>
            OpenCL software driver version string in the form <em>major_number.minor_number</em>.
            </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.PlatformInfo.Profile">
             <summary>
             OpenCL profile string. Returns the profile name supported by the implementation.
             The profile name returned can be one of the following strings:
            
             <list type="bullet">
             <item>FULL_PROFILE - if the implementation supports the OpenCL specification
             (functionality defined as part of the core specification and does not require
             any extensions to be supported).</item>
             <item>EMBEDDED_PROFILE - if the implementation supports the OpenCL embedded
             profile. The embedded profile is defined to be a subset for each version of
             OpenCL.</item>
             </list>
             </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.PlatformInfo.Version">
            <summary>
            OpenCL version string. Returns the OpenCL version supported by the implementation.
            This version string has the following format:
            <para />
            OpenCL<em>&lt;space&gt;</em><em>&lt;major_version.minor_version&gt;</em><em>&lt;space&gt;</em><em>&lt;platform-specific information&gt;</em>
            <para />
            The <em>major_version.minor_version</em> value returned will be 1.2.
            </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.PlatformInfo.Name">
            <summary>
            Platform name string.
            </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.PlatformInfo.Vendor">
            <summary>
            Platform vendor string.
            </summary>
        </member>
        <member name="F:NOpenCL.UnsafeNativeMethods.PlatformInfo.Extensions">
            <summary>
            Returns a space-separated list of extension names (the extension names themselves
            do not contain any spaces) supported by the platform. Extensions defined here must
            be supported by all devices associated with this platform.
            </summary>
        </member>
        <member name="M:NOpenCL.UnsafeNativeMethods.GetNumItems``1(``0[])">
            <summary>
            Helper method to ensure the proper value is passed for the <em>num&lt;items&gt;</em>
            argument of several API methods.
            </summary>
            <param name="items">The list of items, or <c>null</c> if no items are specified.</param>
            <typeparam name="T">The type of elements in the array.</typeparam>
            <returns>The length of <paramref name="items"/>, or 0 if <paramref name="items"/> is <c>null</c>.</returns>
        </member>
        <member name="M:NOpenCL.UnsafeNativeMethods.GetItems``1(``0[])">
            <summary>
            Helper method to ensure the proper value is passed for the <em>&lt;items&gt;</em>
            argument of several API methods.
            </summary>
            <remarks>
            This method allows the user to pass a non-null but empty list of items to the
            managed API wrapper methods, which is not allowed by the underlying OpenCL API.
            In this case, the list is treated as though the user passed <c>null</c> instead.
            </remarks>
            <param name="items">The list of items, or <c>null</c> if no items are specified.</param>
            <typeparam name="T">The type of elements in the array.</typeparam>
            <returns><paramref name="items"/> if it contains at least one item, otherwise <c>null</c>.</returns>
        </member>
        <member name="T:NOpenCL.BuildStatus">
            <summary>
            Returns the build, compile, or link status, whichever was performed last
            on the specified program and device.
            </summary>
            <seealso cref="O:NOpenCL.Program.Build"/>
            <seealso cref="!:Program.Compile"/>
            <seealso cref="!:Program.Link"/>
        </member>
        <member name="F:NOpenCL.BuildStatus.Success">
            <summary>
            The build was successful.
            </summary>
        </member>
        <member name="F:NOpenCL.BuildStatus.None">
            <summary>
            No build, compile, or link has been performed on the specified program and device.
            </summary>
        </member>
        <member name="F:NOpenCL.BuildStatus.Error">
            <summary>
            The build generated an error.
            </summary>
        </member>
        <member name="F:NOpenCL.BuildStatus.InProgress">
            <summary>
            The build has not finished.
            </summary>
        </member>
        <member name="T:NOpenCL.CacheType">
            <summary>
            Specifies the type of global memory cache supported.
            </summary>
        </member>
        <member name="T:NOpenCL.ChannelOrder">
            <summary>
            Specifies the channels contained in each image element, as well as their
            order.
            </summary>
        </member>
        <member name="F:NOpenCL.ChannelOrder.A">
            <summary>
            Each image element consists of a single alpha channel.
            </summary>
        </member>
        <member name="F:NOpenCL.ChannelOrder.R">
            <summary>
            Each image element consists of a single red channel.
            </summary>
        </member>
        <member name="F:NOpenCL.ChannelOrder.RG">
            <summary>
            Each image element consists of two channels: red, green.
            </summary>
        </member>
        <member name="F:NOpenCL.ChannelOrder.RA">
            <summary>
            Each image element consists of two channels: red, alpha.
            </summary>
        </member>
        <member name="F:NOpenCL.ChannelOrder.RGB">
            <summary>
            Each image element consists of three channels: red, green, blue.
            </summary>
            <remarks>
            This format can only be used with <see cref="F:NOpenCL.ChannelType.UnormShort565"/>,
            <see cref="F:NOpenCL.ChannelType.UnormShort555"/>, or <see cref="F:NOpenCL.ChannelType.UnormInt101010"/>.
            </remarks>
        </member>
        <member name="F:NOpenCL.ChannelOrder.RGBA">
            <summary>
            Each image element consists of four channels: red, green, blue, alpha.
            </summary>
        </member>
        <member name="F:NOpenCL.ChannelOrder.BGRA">
            <summary>
            Each image element consists of four channels: blue, green, red, alpha.
            </summary>
        </member>
        <member name="F:NOpenCL.ChannelOrder.ARGB">
            <summary>
            Each image element consists of four channels: alpha, red, green, blue.
            </summary>
            <remarks>
            This format can only be used with <see cref="F:NOpenCL.ChannelType.UnormInt8"/>,
            <see cref="F:NOpenCL.ChannelType.SnormInt8"/>, <see cref="F:NOpenCL.ChannelType.SignedInt8"/>,
            or <see cref="F:NOpenCL.ChannelType.UnsignedInt8"/>.
            </remarks>
        </member>
        <member name="F:NOpenCL.ChannelOrder.Intensity">
            <summary>
            Each image element consists of a single intensity channel.
            </summary>
            <remarks>
            This format can only be used with <see cref="F:NOpenCL.ChannelType.UnormInt8"/>,
            <see cref="F:NOpenCL.ChannelType.UnormInt16"/>, <see cref="F:NOpenCL.ChannelType.SnormInt8"/>,
            <see cref="F:NOpenCL.ChannelType.SnormInt16"/>, <see cref="F:NOpenCL.ChannelType.HalfFloat"/>,
            or <see cref="F:NOpenCL.ChannelType.Float"/>.
            </remarks>
        </member>
        <member name="F:NOpenCL.ChannelOrder.Luminance">
            <summary>
            Each image element consists of a single luminance channel.
            </summary>
            <remarks>
            This format can only be used with <see cref="F:NOpenCL.ChannelType.UnormInt8"/>,
            <see cref="F:NOpenCL.ChannelType.UnormInt16"/>, <see cref="F:NOpenCL.ChannelType.SnormInt8"/>,
            <see cref="F:NOpenCL.ChannelType.SnormInt16"/>, <see cref="F:NOpenCL.ChannelType.HalfFloat"/>,
            or <see cref="F:NOpenCL.ChannelType.Float"/>.
            </remarks>
        </member>
        <member name="F:NOpenCL.ChannelOrder.Rx">
            <summary>
            Each image element consists of a single red channel.
            Similar to <see cref="F:NOpenCL.ChannelOrder.R"/>, except the alpha value at the border is 0.
            </summary>
        </member>
        <member name="F:NOpenCL.ChannelOrder.RGx">
            <summary>
            Each image element consists of two channels: red, green.
            Similar to <see cref="F:NOpenCL.ChannelOrder.RG"/>, except the alpha value at the border is 0.
            </summary>
        </member>
        <member name="F:NOpenCL.ChannelOrder.RGBx">
            <summary>
            Each image element consists of three channels: red, green, blue.
            Similar to <see cref="F:NOpenCL.ChannelOrder.RGB"/>, except the alpha value at the border is 0.
            </summary>
            <remarks>
            This format can only be used with <see cref="F:NOpenCL.ChannelType.UnormShort565"/>,
            <see cref="F:NOpenCL.ChannelType.UnormShort555"/>, or <see cref="F:NOpenCL.ChannelType.UnormInt101010"/>.
            </remarks>
        </member>
        <member name="F:NOpenCL.ChannelOrder.Depth">
            <summary>
            Each image element consists of a single depth channel.
            </summary>
        </member>
        <member name="F:NOpenCL.ChannelOrder.DepthStencil">
            <summary>
            Each image element consists of a single depth stencil channel.
            </summary>
        </member>
        <member name="T:NOpenCL.ChannelType">
            <summary>
            Describes the size of the channel data type. The number of bits per element
            determined by the <see cref="T:NOpenCL.ChannelType"/> and <see cref="T:NOpenCL.ChannelOrder"/>
            must be a power of two.
            </summary>
        </member>
        <member name="F:NOpenCL.ChannelType.SnormInt8">
            <summary>
            Each channel component is a normalized signed 8-bit integer value.
            </summary>
        </member>
        <member name="F:NOpenCL.ChannelType.SnormInt16">
            <summary>
            Each channel component is a normalized signed 16-bit integer value.
            </summary>
        </member>
        <member name="F:NOpenCL.ChannelType.UnormInt8">
            <summary>
            Each channel component is a normalized unsigned 8-bit integer value.
            </summary>
        </member>
        <member name="F:NOpenCL.ChannelType.UnormInt16">
            <summary>
            Each channel component is a normalized unsigned 16-bit integer value.
            </summary>
        </member>
        <member name="F:NOpenCL.ChannelType.UnormShort565">
            <summary>
            Represents a normalized 5-6-5 3-channel RGB image. The channel order
            must be <see cref="F:NOpenCL.ChannelOrder.RGB"/> or <see cref="F:NOpenCL.ChannelOrder.RGBx"/>.
            </summary>
        </member>
        <member name="F:NOpenCL.ChannelType.UnormShort555">
            <summary>
            Represents a normalized x-5-5-5 4-channel xRGB image. The channel order
            must be <see cref="F:NOpenCL.ChannelOrder.RGB"/> or <see cref="F:NOpenCL.ChannelOrder.RGBx"/>.
            </summary>
        </member>
        <member name="F:NOpenCL.ChannelType.UnormInt101010">
            <summary>
            Represents a normalized x-10-10-10 4-channel xRGB image. The channel
            order must be <see cref="F:NOpenCL.ChannelOrder.RGB"/> or <see cref="F:NOpenCL.ChannelOrder.RGBx"/>.
            </summary>
        </member>
        <member name="F:NOpenCL.ChannelType.SignedInt8">
            <summary>
            Each channel component is an unnormalized signed 8-bit integer value.
            </summary>
        </member>
        <member name="F:NOpenCL.ChannelType.SignedInt16">
            <summary>
            Each channel component is an unnormalized signed 16-bit integer value.
            </summary>
        </member>
        <member name="F:NOpenCL.ChannelType.SignedInt32">
            <summary>
            Each channel component is an unnormalized signed 32-bit integer value.
            </summary>
        </member>
        <member name="F:NOpenCL.ChannelType.UnsignedInt8">
            <summary>
            Each channel component is an unnormalized unsigned 8-bit integer value.
            </summary>
        </member>
        <member name="F:NOpenCL.ChannelType.UnsignedInt16">
            <summary>
            Each channel component is an unnormalized unsigned 16-bit integer value.
            </summary>
        </member>
        <member name="F:NOpenCL.ChannelType.UnsignedInt32">
            <summary>
            Each channel component is an unnormalized unsigned 32-bit integer value.
            </summary>
        </member>
        <member name="F:NOpenCL.ChannelType.HalfFloat">
            <summary>
            Each channel component is a 16-bit half-float value.
            </summary>
        </member>
        <member name="F:NOpenCL.ChannelType.Float">
            <summary>
            Each channel component is a single precision floating-point value.
            </summary>
        </member>
        <member name="F:NOpenCL.ChannelType.UnormInt24">
            <summary>
            Each channel component is a normalized unsigned 24-bit integer value.
            </summary>
        </member>
        <member name="P:NOpenCL.CommandQueue.Context">
            <summary>
            Gets the <see cref="P:NOpenCL.CommandQueue.Context"/> associated with this command queue.
            </summary>
            <exception cref="T:System.ObjectDisposedException">if this command queue has been disposed.</exception>
        </member>
        <member name="P:NOpenCL.CommandQueue.Device">
            <summary>
            Gets the <see cref="P:NOpenCL.CommandQueue.Device"/> associated with this command queue.
            </summary>
            <exception cref="T:System.ObjectDisposedException">if this command queue has been disposed.</exception>
        </member>
        <member name="P:NOpenCL.CommandQueue.ReferenceCount">
            <summary>
            Get the command queue reference count.
            </summary>
            <remarks>
            The returned reference count should be considered immediately stale. It is unsuitable
            for general use in applications. This feature is provided for identifying memory leaks.
            </remarks>
            <exception cref="T:System.ObjectDisposedException">if this command queue has been disposed.</exception>
        </member>
        <member name="P:NOpenCL.CommandQueue.Properties">
            <summary>
            Get the properties for the command queue. These properties are specified by the
            <em>properties</em> argument in <see cref="M:NOpenCL.Context.CreateCommandQueue(NOpenCL.Device,NOpenCL.CommandQueueProperties)"/>.
            </summary>
            <exception cref="T:System.ObjectDisposedException">if this command queue has been disposed.</exception>
        </member>
        <member name="P:NOpenCL.CommandQueue.Handle">
            <summary>
            Get the underlying handle for this command queue.
            </summary>
            <exception cref="T:System.ObjectDisposedException">if this command queue has been disposed.</exception>
        </member>
        <member name="M:NOpenCL.CommandQueue.EnqueueTask(NOpenCL.Kernel,NOpenCL.Event[])">
             <summary>
             Enqueues a command to execute a <see cref="T:NOpenCL.Kernel"/> on this command queue's <see cref="P:NOpenCL.CommandQueue.Device"/>.
             </summary>
             <remarks>
             The kernel is executed using a single work-item.
            
             <para><see cref="M:NOpenCL.CommandQueue.EnqueueTask(NOpenCL.Kernel,NOpenCL.Event[])"/> is equivalent to calling
             <see cref="M:NOpenCL.CommandQueue.EnqueueNDRangeKernel(NOpenCL.Kernel,System.IntPtr,System.IntPtr,NOpenCL.Event[])"/> with
             <em>globalWorkSize</em> set to 1, and <em>localWorkSize</em> set to 1.</para>
             </remarks>
             <param name="kernel">A valid <see cref="T:NOpenCL.Kernel"/> object.</param>
             <param name="eventWaitList">The events that need to be complete before this
             command is executed. If the list is null or empty, this command does not
             wait on any event to complete.</param>
             <returns>Returns an event object that identifies this particular kernel execution instance.</returns>
        </member>
        <member name="M:NOpenCL.CommandQueue.EnqueueMarker(NOpenCL.Event[])">
            <summary>
            Enqueues a marker command which waits for either a list of events to complete,
            or all previously enqueued commands to complete.
            </summary>
            <remarks>
            Enqueues a marker command which waits for all events in
            <paramref name="eventWaitList"/> to complete, or if
            <paramref name="eventWaitList"/> is empty it waits for all previously enqueued
            commands to complete before it completes. This command returns an event which
            can be waited on, i.e. this event can be waited on to ensure that all events
            either in <paramref name="eventWaitList"/> or all previously enqueued commands,
            queued before this command, have completed.
            </remarks>
            <param name="eventWaitList">The events that need to be complete before this
            command is executed. If the list is null or empty, this command waits until
            all previous enqueued commands have completed.</param>
            <returns>Returns an event object that identifies this particular command.</returns>
        </member>
        <member name="M:NOpenCL.CommandQueue.EnqueueBarrier(NOpenCL.Event[])">
            <summary>
            A synchronization point that enqueues a barrier operation.
            </summary>
            <remarks>
            Enqueues a barrier command which waits for all events in
            <paramref name="eventWaitList"/> to complete, or if
            <paramref name="eventWaitList"/> is empty it waits for all previously enqueued
            commands to complete before it completes. This command blocks command execution,
            that is, any commands enqueued after it do not execute until it completes. This
            command returns an event which can be waited on, i.e. this event can be waited
            on to ensure that all events either in the <paramref name="eventWaitList"/>
            or all previously enqueued commands, queued before this command, have completed.
            </remarks>
            <param name="eventWaitList">The events that need to be complete before this
            command is executed. If the list is null or empty, this command waits until
            all previous enqueued commands have completed.</param>
            <returns>Returns an event object that identifies this particular command.</returns>
        </member>
        <member name="M:NOpenCL.CommandQueue.Finish">
            <summary>
            Blocks until all previously queued OpenCL commands in the command-queue are
            issued to the associated device and have completed.
            </summary>
            <remarks>
            <see cref="M:NOpenCL.CommandQueue.Finish"/> does not return until all previously queued commands in
            the command queue have been processed and completed. <see cref="M:NOpenCL.CommandQueue.Finish"/> is
            also a synchronization point.
            </remarks>
        </member>
        <member name="M:NOpenCL.CommandQueue.Flush">
             <summary>
             Issues all previously queued OpenCL commands in the command-queue to the device
             associated with the command-queue.
             </summary>
             <remarks>
             <see cref="M:NOpenCL.CommandQueue.Flush"/> only guarantees that all queued commands will eventually be
             submitted to the appropriate device. There is no guarantee that they will be
             complete after <see cref="M:NOpenCL.CommandQueue.Flush"/> returns.
            
             <para>Any blocking commands queued in a command-queue and <see cref="M:NOpenCL.CommandQueue.Dispose"/>
             perform an implicit flush of the command-queue. These blocking commands are
             <see cref="M:NOpenCL.CommandQueue.EnqueueReadBuffer(NOpenCL.Buffer,System.Boolean,System.Int64,System.Int64,System.IntPtr,NOpenCL.Event[])"/>, <see cref="M:NOpenCL.CommandQueue.EnqueueReadBufferRect(NOpenCL.Buffer,System.Boolean,NOpenCL.BufferCoordinates,NOpenCL.BufferCoordinates,NOpenCL.BufferSize,System.Int64,System.Int64,System.Int64,System.Int64,System.IntPtr,NOpenCL.Event[])"/>, or
             <see cref="M:NOpenCL.CommandQueue.EnqueueReadImage(NOpenCL.Image,System.Boolean,NOpenCL.BufferCoordinates,NOpenCL.BufferSize,System.Int64,System.Int64,System.IntPtr,NOpenCL.Event[])"/> with <c>blocking</c> set to <c>true</c>;
             <see cref="M:NOpenCL.CommandQueue.EnqueueWriteBuffer(NOpenCL.Buffer,System.Boolean,System.Int64,System.Int64,System.IntPtr,NOpenCL.Event[])"/>, <see cref="M:NOpenCL.CommandQueue.EnqueueWriteBufferRect(NOpenCL.Buffer,System.Boolean,NOpenCL.BufferCoordinates,NOpenCL.BufferCoordinates,NOpenCL.BufferSize,System.Int64,System.Int64,System.Int64,System.Int64,System.IntPtr,NOpenCL.Event[])"/>, or
             <see cref="M:NOpenCL.CommandQueue.EnqueueWriteImage(NOpenCL.Image,System.Boolean,NOpenCL.BufferCoordinates,NOpenCL.BufferSize,System.Int64,System.Int64,System.IntPtr,NOpenCL.Event[])"/> with <c>blocking_write</c> set to <c>true</c>;
             <see cref="M:NOpenCL.CommandQueue.EnqueueMapBuffer(NOpenCL.Buffer,System.Boolean,NOpenCL.MapFlags,System.Int64,System.Int64,System.IntPtr@,NOpenCL.Event[])"/> or <see cref="M:NOpenCL.CommandQueue.EnqueueMapImage(NOpenCL.Image,System.Boolean,NOpenCL.MapFlags,NOpenCL.BufferCoordinates,NOpenCL.BufferSize,System.Int64@,System.Int64@,System.IntPtr@,NOpenCL.Event[])"/> with
             <c>blocking_map</c> set to <c>true</c>; or <see cref="M:NOpenCL.Event.WaitAll(NOpenCL.Event[])"/>.</para>
            
             <para>To use event objects that refer to commands enqueued in a command-queue
             as event objects to wait on by commands enqueued in a different command-queue,
             the application must call a <see cref="M:NOpenCL.CommandQueue.Flush"/> or any blocking commands that
             perform an implicit flush of the command-queue where the commands that refer
             to these event objects are enqueued.</para>
             </remarks>
        </member>
        <member name="M:NOpenCL.CommandQueue.ThrowIfDisposed">
            <summary>
            Throws <see cref="T:System.ObjectDisposedException"/> if this command queue has been disposed.
            </summary>
            <exception cref="T:System.ObjectDisposedException">if this command queue has been disposed.</exception>
        </member>
        <member name="T:NOpenCL.CommandQueueProperties">
            <summary>
            Specifies additional properties for the <see cref="T:NOpenCL.CommandQueue"/>.
            </summary>
        </member>
        <member name="F:NOpenCL.CommandQueueProperties.None">
            <summary>
            No additional properties are specified.
            </summary>
        </member>
        <member name="F:NOpenCL.CommandQueueProperties.OutOfOrderExecutionModeEnable">
            <summary>
            If set, the commands in the command-queue are executed out-of-order. Otherwise,
            commands are executed in-order.
            </summary>
        </member>
        <member name="F:NOpenCL.CommandQueueProperties.ProfilingEnable">
            <summary>
            If set, the profiling of commands is enabled. Otherwise profiling of commands is disabled.
            </summary>
        </member>
        <member name="M:NOpenCL.Context.CreateSampler(System.Boolean,NOpenCL.AddressingMode,NOpenCL.FilterMode)">
            <summary>
            Creates a sampler object. Samplers contros how elements of an <see cref="T:NOpenCL.Image"/> object are read by
            <a href="http://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/imageFunctions.html"><c>read_image{f|i|ui}</c></a>
            </summary>
            <param name="normalizedCoordinates"><c>true</c> to use normalized coordinates, otherwise <c>false</c>.
            For more information, see <see cref="P:NOpenCL.Sampler.NormalizedCoordinates"/>.</param>
            <param name="addressingMode">Specifies the image addressing-mode, i.e.
            how out-of-range image coordinates are handled.</param>
            <param name="filterMode">Specifies the filtering mode to use.</param>
            <returns>A new sampler.</returns>
        </member>
        <member name="T:NOpenCL.MemObjectType">
            <summary>
            Specifies the type of an OpenCL memory object.
            </summary>
        </member>
        <member name="F:NOpenCL.MemObjectType.Buffer">
            <summary>
            A buffer.
            </summary>
            <seealso cref="T:NOpenCL.Buffer"/>
        </member>
        <member name="F:NOpenCL.MemObjectType.Image2D">
            <summary>
            A 2D image.
            </summary>
            <seealso cref="T:NOpenCL.Image"/>
        </member>
        <member name="F:NOpenCL.MemObjectType.Image3D">
            <summary>
            A 3D image.
            </summary>
            <seealso cref="T:NOpenCL.Image"/>
        </member>
        <member name="F:NOpenCL.MemObjectType.Image2DArray">
            <summary>
            A 2D image array.
            </summary>
            <seealso cref="T:NOpenCL.Image"/>
        </member>
        <member name="F:NOpenCL.MemObjectType.Image1D">
            <summary>
            A 1D image.
            </summary>
            <seealso cref="T:NOpenCL.Image"/>
        </member>
        <member name="F:NOpenCL.MemObjectType.Image1DArray">
            <summary>
            A 1D image array.
            </summary>
            <seealso cref="T:NOpenCL.Image"/>
        </member>
        <member name="F:NOpenCL.MemObjectType.Image1DBuffer">
            <summary>
            A 1D image created from a buffer object.
            </summary>
            <seealso cref="T:NOpenCL.Image"/>
        </member>
        <member name="T:NOpenCL.MigrationFlags">
            <summary>
            Specifies the options for <see cref="M:NOpenCL.CommandQueue.EnqueueMigrateMemObjects(NOpenCL.MemObject[],NOpenCL.MigrationFlags,NOpenCL.Event[])"/>.
            </summary>
        </member>
        <member name="F:NOpenCL.MigrationFlags.None">
            <summary>
            No options are specified.
            </summary>
        </member>
        <member name="F:NOpenCL.MigrationFlags.Host">
            <summary>
            This flag indicates that the specified set of memory objects are to be migrated
            to the host, regardless of the target command-queue.
            </summary>
        </member>
        <member name="F:NOpenCL.MigrationFlags.ContentUndefined">
            <summary>
            This flag indicates that the contents of the set of memory objects are undefined
            after migration. The specified set of memory objects are migrated to the device
            associated with the command queue without incurring the overhead of migrating
            their contents.
            </summary>
        </member>
        <member name="T:NOpenCL.Event">
            <summary>
            To create an instance of <see cref="T:NOpenCL.Event"/>, call <see cref="M:NOpenCL.Context.CreateUserEvent"/>.
            </summary>
        </member>
        <member name="T:NOpenCL.ExecutionStatus">
            <summary>
            Represents the execution status of a command.
            </summary>
        </member>
        <member name="F:NOpenCL.ExecutionStatus.Complete">
            <summary>
            The command has completed.
            </summary>
        </member>
        <member name="F:NOpenCL.ExecutionStatus.Running">
            <summary>
            The device is currently executing this command.
            </summary>
        </member>
        <member name="F:NOpenCL.ExecutionStatus.Submitted">
            <summary>
            The enqueued command has been submitted by the host to the device
            associated with the command-queue.
            </summary>
        </member>
        <member name="F:NOpenCL.ExecutionStatus.Queued">
            <summary>
            The command has been enqueued in the command-queue.
            </summary>
        </member>
        <member name="F:NOpenCL.Extensions.KhrD3D11Sharing.D3D11PreferSharedResourcesKhr">
            <summary>
            If the <c>cl_khr_d3d11_sharing</c> extension is supported, Returns true if
            Direct3D 11 resources created as shared by setting MiscFlags to include
            D3D11_RESOURCE_MISC_SHARED will perform faster when shared with OpenCL,
            compared with resources which have not set this flag. Otherwise returns false.
            </summary>
        </member>
        <member name="F:NOpenCL.Extensions.KhrD3D10Sharing.D3D10PreferSharedResourcesKhr">
            <summary>
            If the <c>cl_khr_d3d10_sharing</c> extension is enabled, returns true if
            Direct3D 10 resources created as shared by setting MiscFlags to include
            D3D10_RESOURCE_MISC_SHARED will perform faster when shared with OpenCL,
            compared with resources which have not set this flag. Otherwise returns false.
            </summary>
        </member>
        <member name="F:NOpenCL.FilterMode.Nearest">
             <summary>
            
             </summary>
             <remarks>
             If the image addressing mode is <see cref="F:NOpenCL.AddressingMode.Repeat"/>,
             the image element at location (<em>i</em>, <em>j</em>, <em>k</em>)
             becomes the image element value, with <em>i</em>, <em>j</em> and
             <em>k</em> computed as follows.
            
             <code>
             u = (s – floor(s)) * wt
             i = (int)floor(u)
             if (i > wt – 1)
               i = i – wt
            
             v = (t – floor(t)) * ht
             j = (int)floor(v)
             if (j > ht – 1)
               j = j – ht
            
             w = (r – floor(r)) * dt
             k = (int)floor(w)
             if (k > dt – 1)
               k = k – dt
             </code>
            
             <para>If the image addressing mode is <see cref="F:NOpenCL.AddressingMode.MirroredRepeat"/>,
             the image element at location (<em>i</em>, <em>j</em>, <em>k</em>)
             becomes the image element value, with <em>i</em>, <em>j</em> and
             <em>k</em> computed as follows.</para>
            
             <code>
             s' = 2.0f * rint(0.5f * s)
             s' = fabs(s – s')
             u = s' * wt
             i = (int)floor(u)
             i = min(i, wt – 1)
            
             t' = 2.0f * rint(0.5f * t)
             t' = fabs(t – t’)
             v = t' * ht
             j = (int)floor(v)
             j = min(j, ht – 1)
            
             r' = 2.0f * rint(0.5f * r)
             r' = fabs(r – r')
             w = r’ * dt
             k = (int)floor(w)
             k = min(k, dt – 1)
             </code>
            
             <para>Otherwise, the image element in the image that is nearest (in
             Manhattan distance) to that specified by (u,v,w) is obtained.</para>
             </remarks>
        </member>
        <member name="T:NOpenCL.MemoryFlags">
            <summary>
            A bit-field that is used to specify allocation and usage information such as the memory
            arena that should be used to allocate the buffer object and how it will be used.
            </summary>
        </member>
        <member name="F:NOpenCL.MemoryFlags.None">
            <summary>
            No flags are specified.
            </summary>
        </member>
        <member name="F:NOpenCL.MemoryFlags.ReadWrite">
            <summary>
            This flag specifies that the memory object will be read and written by a kernel.
            </summary>
        </member>
        <member name="F:NOpenCL.MemoryFlags.WriteOnly">
             <summary>
             This flags specifies that the memory object will be written but not read by a kernel.
             </summary>
             <remarks>
             Reading from a buffer or image object created with <see cref="F:NOpenCL.MemoryFlags.WriteOnly"/> inside a kernel is undefined.
            
             <para><see cref="F:NOpenCL.MemoryFlags.ReadWrite"/> and <see cref="F:NOpenCL.MemoryFlags.WriteOnly"/> are mutually exclusive.</para>
             </remarks>
        </member>
        <member name="F:NOpenCL.MemoryFlags.ReadOnly">
             <summary>
             This flag specifies that the memory object is a read-only memory object when used inside a kernel.
             </summary>
             <remarks>
             Writing to a buffer or image object created with <see cref="F:NOpenCL.MemoryFlags.ReadOnly"/> inside a kernel is undefined.
            
             <para><see cref="F:NOpenCL.MemoryFlags.ReadWrite"/> or <see cref="F:NOpenCL.MemoryFlags.WriteOnly"/> and <see cref="F:NOpenCL.MemoryFlags.ReadOnly"/> are mutually exclusive.</para>
             </remarks>
        </member>
        <member name="F:NOpenCL.MemoryFlags.UseHostPointer">
             <summary>
             This flag indicates that the application wants the OpenCL implementation to
             use memory referenced by a specific host pointer as the storage bits for the
             memory object.
             </summary>
             <remarks>
             OpenCL implementations are allowed to cache the buffer contents pointed
             to by the host pointer in device memory. This cached copy can be used
             when kernels are executed on a device.
            
             <para>The result of OpenCL commands that operate on multiple buffer objects
             created with the same host pointer or overlapping host regions is considered
             to be undefined.</para>
            
             <para>Refer to the
             <a href="http://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/dataTypes.html">description of the alignment rules</a>
             for the host pointer for memory objects (buffer and images) created using
             <see cref="F:NOpenCL.MemoryFlags.UseHostPointer"/>.</para>
             </remarks>
        </member>
        <member name="F:NOpenCL.MemoryFlags.AllocateHostPointer">
            <summary>
            This flag specifies that the application wants the OpenCL implementation to
            allocate memory from host accessible memory.
            </summary>
            <remarks>
            <see cref="F:NOpenCL.MemoryFlags.AllocateHostPointer"/> and <see cref="F:NOpenCL.MemoryFlags.UseHostPointer"/> are
            mutually exclusive.
            </remarks>
        </member>
        <member name="F:NOpenCL.MemoryFlags.CopyHostPointer">
             <summary>
             This flag indicates that the application wants the OpenCL implementation to
             allocate memory for the memory object and copy the data from memory referenced
             by a specified host pointer.
             </summary>
             <remarks>
             <see cref="F:NOpenCL.MemoryFlags.CopyHostPointer"/> and <see cref="F:NOpenCL.MemoryFlags.UseHostPointer"/> are mutually exclusive.
            
             <para><see cref="F:NOpenCL.MemoryFlags.CopyHostPointer"/> can be used with <see cref="F:NOpenCL.MemoryFlags.AllocateHostPointer"/>
             to initialize the contents of the memory object allocated using host-accessible
             (e.g. PCIe) memory.</para>
             </remarks>
        </member>
        <member name="F:NOpenCL.MemoryFlags.HostWriteOnly">
            <summary>
            This flag specifies that the host will only write to the memory object (using
            OpenCL APIs that enqueue a write or a map for write). This can be used to
            optimize write access from the host (e.g. enable write combined allocations for
            memory objects for devices that communicate with the host over a system bus
            such as PCIe).
            </summary>
        </member>
        <member name="F:NOpenCL.MemoryFlags.HostReadOnly">
            <summary>
            This flag specifies that the host will only read the memory object (using OpenCL
            APIs that enqueue a read or a map for read).
            </summary>
            <remarks>
            <see cref="F:NOpenCL.MemoryFlags.HostWriteOnly"/> and <see cref="F:NOpenCL.MemoryFlags.HostReadOnly"/> are mutually exclusive.
            </remarks>
        </member>
        <member name="F:NOpenCL.MemoryFlags.HostNoAccess">
            <summary>
            This flag specifies that the host will not read or write the memory object.
            </summary>
            <remarks>
            <see cref="F:NOpenCL.MemoryFlags.HostWriteOnly"/> or <see cref="F:NOpenCL.MemoryFlags.HostReadOnly"/> and
            <see cref="F:NOpenCL.MemoryFlags.HostNoAccess"/> are mutually exclusive.
            </remarks>
        </member>
        <member name="T:NOpenCL.Sampler">
            <summary>
            To create an instance of <see cref="T:NOpenCL.Sampler"/>, call <see cref="M:NOpenCL.Context.CreateSampler(System.Boolean,NOpenCL.AddressingMode,NOpenCL.FilterMode)"/>.
            For more information, see the documentation for
            <a href="http://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/sampler_t.html"><c>sampler_t</c></a>.
            </summary>
        </member>
        <member name="P:NOpenCL.Sampler.ReferenceCount">
            <summary>
            Get the sampler reference count. The reference count returned should be
            considered immediately stale. It is unsuitable for general use in applications.
            This feature is provided for identifying memory leaks.
            </summary>
        </member>
        <member name="P:NOpenCL.Sampler.Context">
            <summary>
            Get the <see cref="P:NOpenCL.Sampler.Context"/> specified when this sampler was created.
            </summary>
        </member>
        <member name="P:NOpenCL.Sampler.NormalizedCoordinates">
            <summary>
            Get the normalized coordinates value associated with this sampler. This value
            specifies whether the <em>x</em>, <em>y</em> and <em>z</em> coordinates are
            passed in as normalized or unnormalized values.
            </summary>
        </member>
        <member name="P:NOpenCL.Sampler.AddressingMode">
            <summary>
            Get the addressing mode value associated with this sampler.
            </summary>
        </member>
        <member name="P:NOpenCL.Sampler.FilterMode">
            <summary>
            Get the filter mode value associated with this sampler.
            </summary>
        </member>
        <member name="P:NOpenCL.Device.AddressBits">
            <summary>
            The default compute device address space size specified as an unsigned integer
            value in bits. Currently supported values are 32 or 64 bits.
            </summary>
        </member>
        <member name="P:NOpenCL.Device.Available">
            <summary>
            Is true if the device is available and false if the device is not available.
            </summary>
        </member>
        <member name="P:NOpenCL.Device.BuiltInKernels">
            <summary>
            A list of built-in kernels supported by the device. An empty list is
            returned if no built-in kernels are supported by the device.
            </summary>
        </member>
        <member name="P:NOpenCL.Device.CompilerAvailable">
            <summary>
            Is false if the implementation does not have a compiler available to compile
            the program source. Is true if the compiler is available. This can be false
            for the embedded platform profile only.
            </summary>
        </member>
        <member name="P:NOpenCL.Device.DoubleFloatingPointConfiguration">
             <summary>
             Describes double precision floating-point capability of the OpenCL device.
             This is a bit-field that describes one or more of the following values:
            
             <list type="bullet">
             <item><see cref="F:NOpenCL.FloatingPointConfiguration.Denorm"/> - denorms are supported.</item>
             <item><see cref="F:NOpenCL.FloatingPointConfiguration.InfNaN"/> - INF and NaNs are supported.</item>
             <item><see cref="F:NOpenCL.FloatingPointConfiguration.RoundToNearest"/> - round to nearest even rounding mode supported.</item>
             <item><see cref="F:NOpenCL.FloatingPointConfiguration.RoundToZero"/> - round to zero rounding mode supported.</item>
             <item><see cref="F:NOpenCL.FloatingPointConfiguration.RoundToInf"/> - round to positive and negative infinity rounding modes supported.</item>
             <item><see cref="F:NOpenCL.FloatingPointConfiguration.Fma"/> - IEEE754-2008 fused multiply-add is supported.</item>
             <item><see cref="F:NOpenCL.FloatingPointConfiguration.SoftFloat"/> - Basic floating-point operations (such as addition, subtraction, multiplication) are implemented in software.</item>
             </list>
             <para/>
             Double precision is an optional feature so the mandated minimum double
             precision floating-point capability is 0.
             <para/>
             If double precision is supported by the device, then the minimum double
             precision floatingpoint capability must be:
             <c><see cref="F:NOpenCL.FloatingPointConfiguration.Fma"/> | <see cref="F:NOpenCL.FloatingPointConfiguration.RoundToNearest"/> | <see cref="F:NOpenCL.FloatingPointConfiguration.RoundToZero"/> | <see cref="F:NOpenCL.FloatingPointConfiguration.RoundToInf"/> | <see cref="F:NOpenCL.FloatingPointConfiguration.InfNaN"/> | <see cref="F:NOpenCL.FloatingPointConfiguration.Denorm"/></c>
             .
             </summary>
        </member>
        <member name="P:NOpenCL.Device.LittleEndian">
            <summary>
            Is true if the OpenCL device is a little endian device and false otherwise.
            </summary>
        </member>
        <member name="P:NOpenCL.Device.ErrorCorrectionSupport">
            <summary>
            Is true if the device implements error correction for all accesses to compute
            device memory (global and constant). Is false if the device does not implement
            such error correction.
            </summary>
        </member>
        <member name="P:NOpenCL.Device.ExecutionCapabilities">
            <summary>
            Describes the execution capabilities of the device.
            The mandated minimum capability is <see cref="F:NOpenCL.ExecutionCapabilities.Kernel"/>.
            </summary>
        </member>
        <member name="P:NOpenCL.Device.Extensions">
             <summary>
             Returns a list of extension names supported by the device. The list
             of extension names returned can be vendor supported extension names and
             one or more of the following Khronos approved extension names:
            
             <list type="bullet">
             <item>cl_khr_int64_base_atomics</item>
             <item>cl_khr_int64_extended_atomics</item>
             <item>cl_khr_fp16</item>
             <item>cl_khr_gl_sharing</item>
             <item>cl_khr_gl_event</item>
             <item>cl_khr_d3d10_sharing</item>
             <item>cl_khr_dx9_media_sharing</item>
             <item>cl_khr_d3d11_sharing</item>
             </list>
             </summary>
        </member>
        <member name="P:NOpenCL.Device.GlobalCacheSize">
            <summary>
            Size of global memory cache in bytes.
            </summary>
        </member>
        <member name="P:NOpenCL.Device.GlobalCacheType">
            <summary>
            Type of global memory cache supported.
            </summary>
        </member>
        <member name="P:NOpenCL.Device.GlobalCacheLineSize">
            <summary>
            Size of global memory cache line in bytes.
            </summary>
        </member>
        <member name="P:NOpenCL.Device.GlobalMemorySize">
            <summary>
            Size of global device memory in bytes.
            </summary>
        </member>
        <member name="P:NOpenCL.Device.HalfFloatingPointConfiguration">
             <summary>
             Describes the OPTIONAL half precision floating-point capability of the
             OpenCL device. This is a bit-field that describes one or more of the
             following values:
            
             <list type="bullet">
             <item><see cref="F:NOpenCL.FloatingPointConfiguration.Denorm"/> - denorms are supported.</item>
             <item><see cref="F:NOpenCL.FloatingPointConfiguration.InfNaN"/> - INF and NaNs are supported.</item>
             <item><see cref="F:NOpenCL.FloatingPointConfiguration.RoundToNearest"/> - round to nearest even rounding mode supported.</item>
             <item><see cref="F:NOpenCL.FloatingPointConfiguration.RoundToZero"/> - round to zero rounding mode supported.</item>
             <item><see cref="F:NOpenCL.FloatingPointConfiguration.RoundToInf"/> - round to +ve and -ve infinity rounding modes supported.</item>
             <item><see cref="F:NOpenCL.FloatingPointConfiguration.Fma"/> - IEEE754-2008 fused multiply-add is supported.</item>
             <item><see cref="F:NOpenCL.FloatingPointConfiguration.SoftFloat"/> - Basic floating-point operations (such as addition, subtraction, multiplication) are implemented in software.</item>
             </list>
             <para/>
             The required minimum half precision floating-point capability as implemented by this extension is
             <c><see cref="F:NOpenCL.FloatingPointConfiguration.RoundToZero"/></c> or <c><see cref="F:NOpenCL.FloatingPointConfiguration.RoundToInf"/> | <see cref="F:NOpenCL.FloatingPointConfiguration.InfNaN"/></c>
             .
             </summary>
        </member>
        <member name="P:NOpenCL.Device.HostUnifiedMemory">
            <summary>
            Is true if the device and the host have a unified memory subsystem and is false otherwise.
            </summary>
        </member>
        <member name="P:NOpenCL.Device.ImageSupport">
            <summary>
            Is true if images are supported by the OpenCL device and false otherwise.
            </summary>
        </member>
        <member name="P:NOpenCL.Device.Image2DMaxHeight">
            <summary>
            Max height of 2D image in pixels. The minimum value is 8192 if <see cref="P:NOpenCL.Device.ImageSupport"/> is true.
            </summary>
        </member>
        <member name="P:NOpenCL.Device.Image2DMaxWidth">
            <summary>
            Max width of 2D image or 1D image not created from a buffer object in pixels. The minimum value is 8192 if <see cref="P:NOpenCL.Device.ImageSupport"/> is true.
            </summary>
        </member>
        <member name="P:NOpenCL.Device.Image3DMaxDepth">
            <summary>
            Max depth of 3D image in pixels. The minimum value is 2048 if <see cref="P:NOpenCL.Device.ImageSupport"/> is true.
            </summary>
        </member>
        <member name="P:NOpenCL.Device.Image3DMaxHeight">
            <summary>
            Max height of 3D image in pixels. The minimum value is 2048 if <see cref="P:NOpenCL.Device.ImageSupport"/> is true.
            </summary>
        </member>
        <member name="P:NOpenCL.Device.Image3DMaxWidth">
            <summary>
            Max width of 3D image in pixels. The minimum value is 2048 if <see cref="P:NOpenCL.Device.ImageSupport"/> is true.
            </summary>
        </member>
        <member name="P:NOpenCL.Device.ImageMaxBufferSize">
            <summary>
            Max number of pixels for a 1D image created from a buffer object. The minimum value is 65536 if <see cref="P:NOpenCL.Device.ImageSupport"/> is true.
            </summary>
        </member>
        <member name="P:NOpenCL.Device.ImageMaxArraySize">
            <summary>
            Max number of images in a 1D or 2D image array. The minimum value is 2048 if <see cref="P:NOpenCL.Device.ImageSupport"/> is true.
            </summary>
        </member>
        <member name="P:NOpenCL.Device.LinkerAvailable">
            <summary>
            Is false if the implementation does not have a linker available. Is true
            if the linker is available. This can be false for the embedded platform
            profile only. This must be true if <see cref="P:NOpenCL.Device.CompilerAvailable"/> is true.
            </summary>
        </member>
        <member name="P:NOpenCL.Device.LocalMemorySize">
            <summary>
            Size of local memory arena in bytes. The minimum value is 32 KB for devices
            that are not of type <see cref="F:NOpenCL.DeviceType.Custom"/>.
            </summary>
        </member>
        <member name="P:NOpenCL.Device.LocalMemoryType">
            <summary>
            Type of local memory supported. This can be set to <see cref="F:NOpenCL.LocalMemoryType.Local"/>
            implying dedicated local memory storage such as SRAM, or <see cref="F:NOpenCL.LocalMemoryType.Global"/>.
            For custom devices, <see cref="F:NOpenCL.LocalMemoryType.None"/> can also be returned indicating
            no local memory support.
            </summary>
        </member>
        <member name="P:NOpenCL.Device.MaxClockFrequency">
            <summary>
            Maximum configured clock frequency of the device in MHz.
            </summary>
        </member>
        <member name="P:NOpenCL.Device.MaxComputeUnits">
            <summary>
            The number of parallel compute units on the OpenCL device. A work-group
            executes on a single compute unit. The minimum value is 1.
            </summary>
        </member>
        <member name="P:NOpenCL.Device.MaxConstantArguments">
            <summary>
            Max number of arguments declared with the <c>__constant</c> qualifier in
            a kernel. The minimum value is 8 for devices that are not of type <see cref="F:NOpenCL.DeviceType.Custom"/>.
            </summary>
        </member>
        <member name="P:NOpenCL.Device.MaxConstantBufferSize">
            <summary>
            Max size in bytes of a constant buffer allocation. The minimum value is 64
            KB for devices that are not of type <see cref="F:NOpenCL.DeviceType.Custom"/>.
            </summary>
        </member>
        <member name="P:NOpenCL.Device.MaxMemoryAllocationSize">
            <summary>
            Max size of memory object allocation in bytes. The minimum value is max
            (1/4th of <see cref="P:NOpenCL.Device.GlobalMemorySize"/>, 128*1024*1024) for devices that are
            not of type <see cref="F:NOpenCL.DeviceType.Custom"/>.
            </summary>
        </member>
        <member name="P:NOpenCL.Device.MaxParameterSize">
            <summary>
            Max size in bytes of the arguments that can be passed to a kernel. The
            minimum value is 1024 for devices that are not of type <see cref="F:NOpenCL.DeviceType.Custom"/>.
            For this minimum value, only a maximum of 128 arguments can be passed to a kernel.
            </summary>
        </member>
        <member name="P:NOpenCL.Device.MaxReadImageArguments">
            <summary>
            Max number of simultaneous image objects that can be read by a kernel.
            The minimum value is 128 if <see cref="P:NOpenCL.Device.ImageSupport"/> is true.
            </summary>
        </member>
        <member name="P:NOpenCL.Device.MaxSamplers">
            <summary>
            Maximum number of samplers that can be used in a kernel. The minimum value
            is 16 if <see cref="P:NOpenCL.Device.ImageSupport"/> is true.
            </summary>
            <seealso cref="T:NOpenCL.Sampler"/>
        </member>
        <member name="P:NOpenCL.Device.MaxWorkGroupSize">
            <summary>
            Maximum number of work-items in a work-group executing a kernel on a single
            compute unit, using the data parallel execution model.
            (Refer to <see cref="O:NOpenCL.CommandQueue.EnqueueNDRangeKernel"/>). The minimum value is 1.
            </summary>
        </member>
        <member name="P:NOpenCL.Device.MaxWorkItemDimensions">
            <summary>
            Maximum dimensions that specify the global and local work-item IDs used by
            the data parallel execution model. (Refer to <see cref="O:NOpenCL.CommandQueue.EnqueueNDRangeKernel"/>). The
            minimum value is 3 for devices that are not of type <see cref="F:NOpenCL.DeviceType.Custom"/>.
            </summary>
        </member>
        <member name="P:NOpenCL.Device.MaxWorkItemSizes">
            <summary>
            Maximum number of work-items that can be specified in each dimension of
            the work-group to <see cref="O:NOpenCL.CommandQueue.EnqueueNDRangeKernel"/>.
            <para/>
            Returns <em>n</em> <see cref="T:System.IntPtr"/> entries, where <em>n</em> is the
            value returned by the query for <see cref="P:NOpenCL.Device.MaxWorkItemDimensions"/>.
            <para/>
            The minimum value is (1, 1, 1) for devices that are not of type <see cref="F:NOpenCL.DeviceType.Custom"/>.
            </summary>
        </member>
        <member name="P:NOpenCL.Device.MaxWriteImageArguments">
            <summary>
            Max number of simultaneous image objects that can be written to by a
            kernel. The minimum value is 8 if <see cref="P:NOpenCL.Device.ImageSupport"/> is true.
            </summary>
        </member>
        <member name="P:NOpenCL.Device.MemoryBaseAddressAlignment">
            <summary>
            The minimum value is the size (in bits) of the largest OpenCL built-in
            data type supported by the device (long16 in FULL profile, long16 or
            int16 in EMBEDDED profile) for devices that are not of type
            <see cref="F:NOpenCL.DeviceType.Custom"/>.
            </summary>
        </member>
        <member name="P:NOpenCL.Device.MinDataTypeAlignmentSize">
            <summary>
            The smallest alignment in bytes which can be used for any data type.
            </summary>
        </member>
        <member name="P:NOpenCL.Device.Name">
            <summary>
            The device name.
            </summary>
        </member>
        <member name="P:NOpenCL.Device.NativeVectorWidthChar">
            <summary>
            Returns the native ISA vector width. The vector width is defined as
            the number of scalar elements that can be stored in the vector.
            </summary>
        </member>
        <member name="P:NOpenCL.Device.NativeVectorWidthShort">
            <summary>
            Returns the native ISA vector width. The vector width is defined as
            the number of scalar elements that can be stored in the vector.
            </summary>
        </member>
        <member name="P:NOpenCL.Device.NativeVectorWidthInt">
            <summary>
            Returns the native ISA vector width. The vector width is defined as
            the number of scalar elements that can be stored in the vector.
            </summary>
        </member>
        <member name="P:NOpenCL.Device.NativeVectorWidthLong">
            <summary>
            Returns the native ISA vector width. The vector width is defined as
            the number of scalar elements that can be stored in the vector.
            </summary>
        </member>
        <member name="P:NOpenCL.Device.NativeVectorWidthFloat">
            <summary>
            Returns the native ISA vector width. The vector width is defined as
            the number of scalar elements that can be stored in the vector.
            </summary>
        </member>
        <member name="P:NOpenCL.Device.NativeVectorWidthDouble">
             <summary>
             Returns the native ISA vector width. The vector width is defined as
             the number of scalar elements that can be stored in the vector.
            
             <para>If double precision is not supported, this must return 0.</para>
             </summary>
        </member>
        <member name="P:NOpenCL.Device.NativeVectorWidthHalf">
             <summary>
             Returns the native ISA vector width. The vector width is defined as
             the number of scalar elements that can be stored in the vector.
            
             <para>If the <c>cl_khr_fp16</c> extension is not supported, this must return 0.</para>
             </summary>
        </member>
        <member name="P:NOpenCL.Device.OpenCLVersion">
            <summary>
            OpenCL C version string. Returns the highest OpenCL C version supported
            by the compiler for this device that is not of type <see cref="F:NOpenCL.DeviceType.Custom"/>.
            This version string has the following format:
            <para/>
            <em>OpenCL&lt;space&gt;C&lt;space&gt;&lt;major_version.minor_version&gt;&lt;space&gt;&lt;vendor-specific information&gt;</em>
            <para/>
            The <em>major_version.minor_version</em> value returned must be 1.2 if <see cref="P:NOpenCL.Device.Version"/> is OpenCL 1.2.
            <para/>
            The <em>major_version.minor_version</em> value returned must be 1.1 if <see cref="P:NOpenCL.Device.Version"/> is OpenCL 1.1.
            </summary>
        </member>
        <member name="P:NOpenCL.Device.Parent">
            <summary>
            Returns the the parent <see cref="T:NOpenCL.Device"/> to which this sub-device belongs.
            If device is a root-level device, this property is <c>null</c>.
            </summary>
        </member>
        <member name="P:NOpenCL.Device.PartitionMaxSubDevices">
            <summary>
            Returns the maximum number of sub-devices that can be created when a
            device is partitioned. The value returned cannot exceed <see cref="P:NOpenCL.Device.MaxComputeUnits"/>.
            </summary>
        </member>
        <member name="P:NOpenCL.Device.PartitionProperties">
             <summary>
             Returns the list of partition types supported by device. This is an array
             of <see cref="T:NOpenCL.PartitionProperty"/> values drawn from the following list:
            
             <list type="bullet">
             <item><see cref="F:NOpenCL.PartitionProperty.PartitionEqually"/></item>
             <item><see cref="F:NOpenCL.PartitionProperty.PartitionByCounts"/></item>
             <item><see cref="F:NOpenCL.PartitionProperty.PartitionByAffinityDomain"/></item>
             </list>
            
             If the device does not support any partition types, a value of 0 will be returned.
             </summary>
        </member>
        <member name="P:NOpenCL.Device.PartitionAffinityDomain">
             <summary>
             Returns the list of supported affinity domains for partitioning the device
             using <see cref="F:NOpenCL.PartitionProperty.PartitionByAffinityDomain"/>. This is a
             bit-field that describes one or more of the following values:
            
             <list type="bullet">
             <item><see cref="F:NOpenCL.AffinityDomain.Numa"/></item>
             <item><see cref="F:NOpenCL.AffinityDomain.L4Cache"/></item>
             <item><see cref="F:NOpenCL.AffinityDomain.L3Cache"/></item>
             <item><see cref="F:NOpenCL.AffinityDomain.L2Cache"/></item>
             <item><see cref="F:NOpenCL.AffinityDomain.L1Cache"/></item>
             <item><see cref="F:NOpenCL.AffinityDomain.NextPartitionable"/></item>
             </list>
            
             If the device does not support any affinity domains, <see cref="F:NOpenCL.AffinityDomain.None"/> will be returned.
             </summary>
        </member>
        <member name="P:NOpenCL.Device.Platform">
            <summary>
            The platform associated with this device.
            </summary>
        </member>
        <member name="P:NOpenCL.Device.PreferredVectorWidthChar">
            <summary>
            Preferred native vector width size for built-in scalar types that can be put
            into vectors. The vector width is defined as the number of scalar elements
            that can be stored in the vector.
            </summary>
        </member>
        <member name="P:NOpenCL.Device.PreferredVectorWidthShort">
            <summary>
            Preferred native vector width size for built-in scalar types that can be put
            into vectors. The vector width is defined as the number of scalar elements
            that can be stored in the vector.
            </summary>
        </member>
        <member name="P:NOpenCL.Device.PreferredVectorWidthInt">
            <summary>
            Preferred native vector width size for built-in scalar types that can be put
            into vectors. The vector width is defined as the number of scalar elements
            that can be stored in the vector.
            </summary>
        </member>
        <member name="P:NOpenCL.Device.PreferredVectorWidthLong">
            <summary>
            Preferred native vector width size for built-in scalar types that can be put
            into vectors. The vector width is defined as the number of scalar elements
            that can be stored in the vector.
            </summary>
        </member>
        <member name="P:NOpenCL.Device.PreferredVectorWidthFloat">
            <summary>
            Preferred native vector width size for built-in scalar types that can be put
            into vectors. The vector width is defined as the number of scalar elements
            that can be stored in the vector.
            </summary>
        </member>
        <member name="P:NOpenCL.Device.PreferredVectorWidthDouble">
             <summary>
             Preferred native vector width size for built-in scalar types that can be put
             into vectors. The vector width is defined as the number of scalar elements
             that can be stored in the vector.
            
             <para>If double precision is not supported, this must return 0.</para>
             </summary>
        </member>
        <member name="P:NOpenCL.Device.PreferredVectorWidthHalf">
             <summary>
             Preferred native vector width size for built-in scalar types that can be put
             into vectors. The vector width is defined as the number of scalar elements
             that can be stored in the vector.
            
             <para>If the <c>cl_khr_fp16</c> extension is not supported, this must return 0.</para>
             </summary>
        </member>
        <member name="P:NOpenCL.Device.PrintfBufferSize">
            <summary>
            Maximum size of the internal buffer that holds the output of printf calls from
            a kernel. The minimum value for the FULL profile is 1 MB.
            </summary>
        </member>
        <member name="P:NOpenCL.Device.PreferredInteropUserSync">
            <summary>
            Is true if the device's preference is for the user to be responsible for
            synchronization, when sharing memory objects between OpenCL and other APIs
            such as DirectX, false if the device / implementation has a performant path
            for performing synchronization of memory object shared between OpenCL and
            other APIs such as DirectX.
            </summary>
        </member>
        <member name="P:NOpenCL.Device.Profile">
             <summary>
             OpenCL profile string. Returns the profile name supported by the device
             (see note). The profile name returned can be one of the following strings:
            
             <list type="bullet">
             <item>FULL_PROFILE - if the device supports the OpenCL specification (functionality defined as part of the core specification and does not require any extensions to be supported).</item>
             <item>EMBEDDED_PROFILE - if the device supports the OpenCL embedded profile.</item>
             </list>
             </summary>
        </member>
        <member name="P:NOpenCL.Device.ProfilingTimerResolution">
            <summary>
            Describes the resolution of device timer. This is measured in nanoseconds.
            </summary>
        </member>
        <member name="P:NOpenCL.Device.QueueProperties">
            <summary>
            Describes the command-queue properties supported by the device.
            </summary>
        </member>
        <member name="P:NOpenCL.Device.ReferenceCount">
            <summary>
            Returns the device reference count. If the device is a root-level device,
            a reference count of one is returned.
            </summary>
        </member>
        <member name="P:NOpenCL.Device.SingleFloatingPointConfiguration">
             <summary>
             Describes single precision floating-point capability of the device.
             This is a bit-field that describes one or more of the following values:
            
             <list type="bullet">
             <item><see cref="F:NOpenCL.FloatingPointConfiguration.Denorm"/> - denorms are supported.</item>
             <item><see cref="F:NOpenCL.FloatingPointConfiguration.InfNaN"/> - INF and quiet NaNs are supported.</item>
             <item><see cref="F:NOpenCL.FloatingPointConfiguration.RoundToNearest"/> - round to nearest even rounding mode supported.</item>
             <item><see cref="F:NOpenCL.FloatingPointConfiguration.RoundToZero"/> - round to zero rounding mode supported.</item>
             <item><see cref="F:NOpenCL.FloatingPointConfiguration.RoundToInf"/> - round to +ve and -ve infinity rounding modes supported.</item>
             <item><see cref="F:NOpenCL.FloatingPointConfiguration.Fma"/> - IEEE754-2008 fused multiply-add is supported.</item>
             <item><see cref="F:NOpenCL.FloatingPointConfiguration.CorrectlyRoundedDivideSqrt"/> - divide and sqrt are correctly rounded as defined by the IEEE754 specification.</item>
             <item><see cref="F:NOpenCL.FloatingPointConfiguration.SoftFloat"/> - Basic floating-point operations (such as addition, subtraction, multiplication) are implemented in software.</item>
             </list>
            
             The mandated minimum floating-point capability for devices that are
             not of type <see cref="F:NOpenCL.DeviceType.Custom"/> is
             <see cref="F:NOpenCL.FloatingPointConfiguration.RoundToNearest"/> |
             <see cref="F:NOpenCL.FloatingPointConfiguration.InfNaN"/>.
             </summary>
        </member>
        <member name="P:NOpenCL.Device.DeviceType">
            <summary>
            The OpenCL device type. Currently supported values are one of or a
            combination of: <see cref="F:NOpenCL.DeviceType.Cpu"/>, <see cref="F:NOpenCL.DeviceType.Gpu"/>,
            <see cref="F:NOpenCL.DeviceType.Accelerator"/>, <see cref="F:NOpenCL.DeviceType.Default"/>, a
            combination of the above types, or <see cref="F:NOpenCL.DeviceType.Custom"/>.
            </summary>
        </member>
        <member name="P:NOpenCL.Device.Vendor">
            <summary>
            The vendor name.
            </summary>
        </member>
        <member name="P:NOpenCL.Device.VendorID">
            <summary>
            A unique device vendor identifier. An example of a unique device identifier
            could be the PCIe ID.
            </summary>
        </member>
        <member name="P:NOpenCL.Device.Version">
            <summary>
            OpenCL version string. Returns the OpenCL version supported by the device.
            This version string has the following format:
            <para/>
            <em>OpenCL&lt;space&gt;&lt;major_version.minor_version&gt;&lt;space&gt;&lt;vendor-specific information&gt;</em>
            <para/>
            The <em>major_version.minor_version</em> value returned will be 1.1.
            </summary>
        </member>
        <member name="P:NOpenCL.Device.DriverVersion">
            <summary>
            OpenCL software driver version string in the form <em>major_number.minor_number</em>.
            </summary>
        </member>
        <member name="M:NOpenCL.Device.PartitionEqually(System.Int32)">
            <summary>
            Split the aggregate device into as many smaller aggregate devices as can
            be created, each containing <paramref name="partitionSize"/> compute units.
            If <paramref name="partitionSize"/> does not divide evenly into
            <see cref="P:NOpenCL.Device.MaxComputeUnits"/>, then the remaining compute units are not used.
            </summary>
            <param name="partitionSize">The size of the partitions to be created.</param>
            <returns>A collection of sub-devices representing the created partitions.</returns>
        </member>
        <member name="M:NOpenCL.Device.Partition(System.Int32[])">
            <summary>
            Split the aggregate device into smaller aggregate devices according to the
            specified <paramref name="partitionSizes"/>. For each nonzero count <em>m</em>
            in the list, a sub-device is created with <em>m</em> compute units in it.
            <para/>
            The number of non-zero count entries in the list may not exceed <see cref="P:NOpenCL.Device.PartitionMaxSubDevices"/>.
            The total number of compute units specified may not exceed <see cref="P:NOpenCL.Device.MaxComputeUnits"/>.
            </summary>
            <param name="partitionSizes">The size of the partitions to be created.</param>
            <returns>A collection of sub-devices representing the created partitions.</returns>
        </member>
        <member name="M:NOpenCL.Device.PartitionByAffinityDomain(NOpenCL.AffinityDomain)">
             <summary>
             Split the device into smaller aggregate devices containing one or more compute
             units that all share part of a cache hierarchy. The value accompanying this
             property may be drawn from the following list:
            
             <list type="bullet">
             <item><see cref="F:NOpenCL.AffinityDomain.Numa"/> - Split the device into sub-devices comprised of compute units that share a NUMA node.</item>
             <item><see cref="F:NOpenCL.AffinityDomain.L4Cache"/> - Split the device into sub-devices comprised of compute units that share a level 4 data cache.</item>
             <item><see cref="F:NOpenCL.AffinityDomain.L3Cache"/> - Split the device into sub-devices comprised of compute units that share a level 3 data cache.</item>
             <item><see cref="F:NOpenCL.AffinityDomain.L2Cache"/> - Split the device into sub-devices comprised of compute units that share a level 2 data cache.</item>
             <item><see cref="F:NOpenCL.AffinityDomain.L1Cache"/> - Split the device into sub-devices comprised of compute units that share a level 1 data cache.</item>
             <item><see cref="F:NOpenCL.AffinityDomain.NextPartitionable"/> - Split the device along the next partitionable affinity domain. The implementation shall find the first level along which the device or sub-device may be further subdivided in the order NUMA, L4, L3, L2, L1, and partition the device into sub-devices comprised of compute units that share memory subsystems at this level.</item>
             </list>
            
             The user may determine what happened by checking <see cref="P:NOpenCL.Device.PartitionType"/> on the sub-devices.
             </summary>
             <param name="affinityDomain">Specifies the cache hierarchy shared by the partitioned compute units.</param>
             <returns>A collection of sub-devices representing the created partitions.</returns>
        </member>
        <member name="T:NOpenCL.ExecutionCapabilities">
            <summary>
            Describes the execution capabilities of the device.
            The mandated minimum capability is <see cref="F:NOpenCL.ExecutionCapabilities.Kernel"/>.
            </summary>
            <seealso cref="P:NOpenCL.Device.ExecutionCapabilities"/>
        </member>
        <member name="F:NOpenCL.ExecutionCapabilities.None">
            <summary>
            No capabilities are specified.
            </summary>
        </member>
        <member name="F:NOpenCL.ExecutionCapabilities.Kernel">
            <summary>
            The OpenCL device can execute OpenCL kernels.
            </summary>
        </member>
        <member name="F:NOpenCL.ExecutionCapabilities.NativeKernel">
            <summary>
            The OpenCL device can execute native kernels.
            </summary>
        </member>
        <member name="M:NOpenCL.Platform.UnloadCompiler">
            <summary>
            Allows the implementation to release the resources allocated by the OpenCL compiler for this platform.
            </summary>
            <remarks>
            This is a hint from the application and does not guarantee that the compiler will not be used
            in the future or that the compiler will actually be unloaded by the implementation. Calls to
            <see cref="O:NOpenCL.Program.Build"/>, <see cref="!:Program.Compile"/>, or <see cref="!:Context.LinkProgram"/>
            after <see cref="M:NOpenCL.Platform.UnloadCompiler"/> will reload the compiler, if necessary, to build the
            appropriate program executable.
            </remarks>
        </member>
    </members>
</doc>
